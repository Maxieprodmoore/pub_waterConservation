<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <!----Link to fonts----->
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;1,300;1,400&display=swap" rel="stylesheet">
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Raleway:ital,wght@0,700;0,900;1,700;1,900&display=swap" rel="stylesheet">
        <!----End of Fonts Compilation---->  

        <!------------Shoelace components--------------->
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.0.0-beta.64/dist/themes/light.css">
            <script src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.0.0-beta.64/dist/shoelace.js" defer=""></script>
            <script data-shoelace="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.0.0-beta.64/dist/">// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"2iWhf":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "d31a9c9d057270d2";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"b6HaR":[function(require,module,exports) {
var _dialogJs = require("@shoelace-style/shoelace/dist/components/dialog/dialog.js");
var _buttonJs = require("@shoelace-style/shoelace/dist/components/button/button.js");
var _iconButtonJs = require("@shoelace-style/shoelace/dist/components/icon-button/icon-button.js");
var _drawerJs = require("@shoelace-style/shoelace/dist/components/drawer/drawer.js");
var _iconJs = require("@shoelace-style/shoelace/dist/components/icon/icon.js");
var _tabGroupJs = require("@shoelace-style/shoelace/dist/components/tab-group/tab-group.js");
var _tabPanelJs = require("@shoelace-style/shoelace/dist/components/tab-panel/tab-panel.js");
var _tabJs = require("@shoelace-style/shoelace/dist/components/tab/tab.js");
var _tooltipJs = require("@shoelace-style/shoelace/dist/components/tooltip/tooltip.js");
var _switchJs = require("@shoelace-style/shoelace/dist/components/switch/switch.js");

},{"@shoelace-style/shoelace/dist/components/dialog/dialog.js":"2Kqgv","@shoelace-style/shoelace/dist/components/button/button.js":"9AbKL","@shoelace-style/shoelace/dist/components/icon-button/icon-button.js":"9ii4L","@shoelace-style/shoelace/dist/components/drawer/drawer.js":"1eEuu","@shoelace-style/shoelace/dist/components/icon/icon.js":"le94t","@shoelace-style/shoelace/dist/components/tab-group/tab-group.js":"3V6Ki","@shoelace-style/shoelace/dist/components/tab-panel/tab-panel.js":"7mIsr","@shoelace-style/shoelace/dist/components/tab/tab.js":"hsPiV","@shoelace-style/shoelace/dist/components/tooltip/tooltip.js":"6RAKh","@shoelace-style/shoelace/dist/components/switch/switch.js":"4qLvQ"}],"2Kqgv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunkZYIXUTR3Js.SlDialog
);
var _chunkZYIXUTR3Js = require("../../chunks/chunk.ZYIXUTR3.js");
var _chunkSXNB3LL3Js = require("../../chunks/chunk.SXNB3LL3.js");
var _chunkDTSUHNT6Js = require("../../chunks/chunk.DTSUHNT6.js");
var _chunkST4GEPNZJs = require("../../chunks/chunk.ST4GEPNZ.js");
var _chunkDREYVBRRJs = require("../../chunks/chunk.DREYVBRR.js");
var _chunk5TL5QPK4Js = require("../../chunks/chunk.5TL5QPK4.js");
var _chunkQSLHMB3EJs = require("../../chunks/chunk.QSLHMB3E.js");
var _chunkWCAFNYXWJs = require("../../chunks/chunk.WCAFNYXW.js");
var _chunk6JY65IM5Js = require("../../chunks/chunk.6JY65IM5.js");
var _chunkUTEQRIIYJs = require("../../chunks/chunk.UTEQRIIY.js");
var _chunkW2WMQSCEJs = require("../../chunks/chunk.W2WMQSCE.js");
var _chunkAN2XMPAVJs = require("../../chunks/chunk.AN2XMPAV.js");
var _chunkIBSPWXHKJs = require("../../chunks/chunk.IBSPWXHK.js");
var _chunkL4IDTG64Js = require("../../chunks/chunk.L4IDTG64.js");
var _chunkC7PPQWMAJs = require("../../chunks/chunk.C7PPQWMA.js");
var _chunkNFF2HMITJs = require("../../chunks/chunk.NFF2HMIT.js");
var _chunkHEOUBJ7TJs = require("../../chunks/chunk.HEOUBJ7T.js");
var _chunkUJSH3WGMJs = require("../../chunks/chunk.UJSH3WGM.js");
var _chunk4KUWHA33Js = require("../../chunks/chunk.4KUWHA33.js");
var _chunkKJOCH52QJs = require("../../chunks/chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("../../chunks/chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.ZYIXUTR3.js":"FlqbK","../../chunks/chunk.SXNB3LL3.js":"cN7v8","../../chunks/chunk.DTSUHNT6.js":"a7RTw","../../chunks/chunk.ST4GEPNZ.js":"ao9ex","../../chunks/chunk.DREYVBRR.js":"jLpn7","../../chunks/chunk.5TL5QPK4.js":"akO45","../../chunks/chunk.QSLHMB3E.js":"2Tw6u","../../chunks/chunk.WCAFNYXW.js":"9Qo42","../../chunks/chunk.6JY65IM5.js":"d40Fl","../../chunks/chunk.UTEQRIIY.js":"h4h4P","../../chunks/chunk.W2WMQSCE.js":"9o2tn","../../chunks/chunk.AN2XMPAV.js":"2bW2A","../../chunks/chunk.IBSPWXHK.js":"bRaa7","../../chunks/chunk.L4IDTG64.js":"5bB1j","../../chunks/chunk.C7PPQWMA.js":"szhSB","../../chunks/chunk.NFF2HMIT.js":"fX0do","../../chunks/chunk.HEOUBJ7T.js":"3YVet","../../chunks/chunk.UJSH3WGM.js":"7vHmo","../../chunks/chunk.4KUWHA33.js":"69rgo","../../chunks/chunk.KJOCH52Q.js":"e6TXF","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.BD26TKS4.js":"1j2NX","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"FlqbK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlDialog", ()=>SlDialog
);
var _chunkSXNB3LL3Js = require("./chunk.SXNB3LL3.js");
var _chunkST4GEPNZJs = require("./chunk.ST4GEPNZ.js");
var _chunkDREYVBRRJs = require("./chunk.DREYVBRR.js");
var _chunk5TL5QPK4Js = require("./chunk.5TL5QPK4.js");
var _chunk6JY65IM5Js = require("./chunk.6JY65IM5.js");
var _chunkUTEQRIIYJs = require("./chunk.UTEQRIIY.js");
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkKJOCH52QJs = require("./chunk.KJOCH52Q.js");
var _chunkBD26TKS4Js = require("./chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("./chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/components/dialog/dialog.ts
var hasPreventScroll = _chunkSXNB3LL3Js.isPreventScrollSupported();
var SlDialog = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.hasSlotController = new _chunk5TL5QPK4Js.HasSlotController(this, "footer");
        this.open = false;
        this.label = "";
        this.noHeader = false;
    }
    connectedCallback() {
        super.connectedCallback();
        this.modal = new _chunkSXNB3LL3Js.Modal(this);
    }
    firstUpdated() {
        this.dialog.hidden = !this.open;
        if (this.open) {
            this.modal.activate();
            _chunkST4GEPNZJs.lockBodyScrolling(this);
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        _chunkST4GEPNZJs.unlockBodyScrolling(this);
    }
    async show() {
        if (this.open) return;
        this.open = true;
        return _chunkI4TE3TJVJs.waitForEvent(this, "sl-after-show");
    }
    async hide() {
        if (!this.open) return;
        this.open = false;
        return _chunkI4TE3TJVJs.waitForEvent(this, "sl-after-hide");
    }
    requestClose() {
        const slRequestClose = _chunkI4TE3TJVJs.emit(this, "sl-request-close", {
            cancelable: true
        });
        if (slRequestClose.defaultPrevented) {
            const animation = _chunkUTEQRIIYJs.getAnimation(this, "dialog.denyClose");
            _chunk6JY65IM5Js.animateTo(this.panel, animation.keyframes, animation.options);
            return;
        }
        this.hide();
    }
    handleKeyDown(event) {
        if (event.key === "Escape") {
            event.stopPropagation();
            this.requestClose();
        }
    }
    async handleOpenChange() {
        if (this.open) {
            _chunkI4TE3TJVJs.emit(this, "sl-show");
            this.originalTrigger = document.activeElement;
            this.modal.activate();
            _chunkST4GEPNZJs.lockBodyScrolling(this);
            await Promise.all([
                _chunk6JY65IM5Js.stopAnimations(this.dialog),
                _chunk6JY65IM5Js.stopAnimations(this.overlay)
            ]);
            this.dialog.hidden = false;
            if (hasPreventScroll) {
                const slInitialFocus = _chunkI4TE3TJVJs.emit(this, "sl-initial-focus", {
                    cancelable: true
                });
                if (!slInitialFocus.defaultPrevented) this.panel.focus({
                    preventScroll: true
                });
            }
            const panelAnimation = _chunkUTEQRIIYJs.getAnimation(this, "dialog.show");
            const overlayAnimation = _chunkUTEQRIIYJs.getAnimation(this, "dialog.overlay.show");
            await Promise.all([
                _chunk6JY65IM5Js.animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
                _chunk6JY65IM5Js.animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
            ]);
            if (!hasPreventScroll) {
                const slInitialFocus = _chunkI4TE3TJVJs.emit(this, "sl-initial-focus", {
                    cancelable: true
                });
                if (!slInitialFocus.defaultPrevented) this.panel.focus({
                    preventScroll: true
                });
            }
            _chunkI4TE3TJVJs.emit(this, "sl-after-show");
        } else {
            _chunkI4TE3TJVJs.emit(this, "sl-hide");
            this.modal.deactivate();
            await Promise.all([
                _chunk6JY65IM5Js.stopAnimations(this.dialog),
                _chunk6JY65IM5Js.stopAnimations(this.overlay)
            ]);
            const panelAnimation = _chunkUTEQRIIYJs.getAnimation(this, "dialog.hide");
            const overlayAnimation = _chunkUTEQRIIYJs.getAnimation(this, "dialog.overlay.hide");
            await Promise.all([
                _chunk6JY65IM5Js.animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
                _chunk6JY65IM5Js.animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
            ]);
            this.dialog.hidden = true;
            _chunkST4GEPNZJs.unlockBodyScrolling(this);
            const trigger = this.originalTrigger;
            if (trigger && typeof trigger.focus === "function") setTimeout(()=>trigger.focus()
            );
            _chunkI4TE3TJVJs.emit(this, "sl-after-hide");
        }
    }
    render() {
        return _chunk2VBMOEKGJs.$`
      <div
        part="base"
        class=${_chunkW2WMQSCEJs.o({
            dialog: true,
            "dialog--open": this.open,
            "dialog--has-footer": this.hasSlotController.test("footer")
        })}
        @keydown=${this.handleKeyDown}
      >
        <div part="overlay" class="dialog__overlay" @click=${this.requestClose} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${_chunkKJOCH52QJs.l(this.noHeader ? this.label : void 0)}
          aria-labelledby=${_chunkKJOCH52QJs.l(!this.noHeader ? "title" : void 0)}
          tabindex="0"
        >
          ${!this.noHeader ? _chunk2VBMOEKGJs.$`
                <header part="header" class="dialog__header">
                  <span part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label || String.fromCharCode(65279)} </slot>
                  </span>
                  <sl-icon-button
                    exportparts="base:close-button"
                    class="dialog__close"
                    name="x"
                    library="system"
                    @click="${this.requestClose}"
                  ></sl-icon-button>
                </header>
              ` : ""}

          <div part="body" class="dialog__body">
            <slot></slot>
          </div>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
    }
};
SlDialog.styles = _chunkDREYVBRRJs.dialog_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".dialog")
], SlDialog.prototype, "dialog", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".dialog__panel")
], SlDialog.prototype, "panel", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".dialog__overlay")
], SlDialog.prototype, "overlay", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlDialog.prototype, "open", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        reflect: true
    })
], SlDialog.prototype, "label", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        attribute: "no-header",
        type: Boolean,
        reflect: true
    })
], SlDialog.prototype, "noHeader", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("open", {
        waitUntilFirstUpdate: true
    })
], SlDialog.prototype, "handleOpenChange", 1);
SlDialog = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-dialog")
], SlDialog);
_chunkUTEQRIIYJs.setDefaultAnimation("dialog.show", {
    keyframes: [
        {
            opacity: 0,
            transform: "scale(0.8)"
        },
        {
            opacity: 1,
            transform: "scale(1)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("dialog.hide", {
    keyframes: [
        {
            opacity: 1,
            transform: "scale(1)"
        },
        {
            opacity: 0,
            transform: "scale(0.8)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("dialog.denyClose", {
    keyframes: [
        {
            transform: "scale(1)"
        },
        {
            transform: "scale(1.02)"
        },
        {
            transform: "scale(1)"
        }
    ],
    options: {
        duration: 250
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("dialog.overlay.show", {
    keyframes: [
        {
            opacity: 0
        },
        {
            opacity: 1
        }
    ],
    options: {
        duration: 250
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("dialog.overlay.hide", {
    keyframes: [
        {
            opacity: 1
        },
        {
            opacity: 0
        }
    ],
    options: {
        duration: 250
    }
});

},{"./chunk.SXNB3LL3.js":"cN7v8","./chunk.ST4GEPNZ.js":"ao9ex","./chunk.DREYVBRR.js":"jLpn7","./chunk.5TL5QPK4.js":"akO45","./chunk.6JY65IM5.js":"d40Fl","./chunk.UTEQRIIY.js":"h4h4P","./chunk.W2WMQSCE.js":"9o2tn","./chunk.KJOCH52Q.js":"e6TXF","./chunk.BD26TKS4.js":"1j2NX","./chunk.I4TE3TJV.js":"i4CGq","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cN7v8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPreventScrollSupported", ()=>isPreventScrollSupported
);
parcelHelpers.export(exports, "Modal", ()=>Modal
);
var _chunkDTSUHNT6Js = require("./chunk.DTSUHNT6.js");
// src/internal/support.ts
function isPreventScrollSupported() {
    let supported = false;
    document.createElement("div").focus({
        get preventScroll () {
            supported = true;
            return false;
        }
    });
    return supported;
}
// src/internal/modal.ts
var activeModals = [];
var Modal = class {
    constructor(element){
        this.tabDirection = "forward";
        this.element = element;
        this.handleFocusIn = this.handleFocusIn.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
    }
    activate() {
        activeModals.push(this.element);
        document.addEventListener("focusin", this.handleFocusIn);
        document.addEventListener("keydown", this.handleKeyDown);
    }
    deactivate() {
        activeModals = activeModals.filter((modal)=>modal !== this.element
        );
        document.removeEventListener("focusin", this.handleFocusIn);
        document.removeEventListener("keydown", this.handleKeyDown);
    }
    isActive() {
        return activeModals[activeModals.length - 1] === this.element;
    }
    handleFocusIn(event) {
        const path = event.composedPath();
        if (this.isActive() && !path.includes(this.element)) {
            const { start , end  } = _chunkDTSUHNT6Js.getTabbableBoundary(this.element);
            const target = this.tabDirection === "forward" ? start : end;
            if (typeof (target == null ? void 0 : target.focus) === "function") target.focus({
                preventScroll: true
            });
        }
    }
    handleKeyDown(event) {
        if (event.key === "Tab" && event.shiftKey) {
            this.tabDirection = "backward";
            setTimeout(()=>this.tabDirection = "forward"
            );
        }
    }
};

},{"./chunk.DTSUHNT6.js":"a7RTw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a7RTw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTabbableBoundary", ()=>getTabbableBoundary
);
// src/internal/tabbable.ts
function isTabbable(el) {
    const tag = el.tagName.toLowerCase();
    if (el.getAttribute("tabindex") === "-1") return false;
    if (el.hasAttribute("disabled")) return false;
    if (el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") !== "false") return false;
    if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) return false;
    if (!el.offsetParent) return false;
    if (window.getComputedStyle(el).visibility === "hidden") return false;
    if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) return true;
    if (el.hasAttribute("tabindex")) return true;
    if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") return true;
    return [
        "button",
        "input",
        "select",
        "textarea",
        "a",
        "audio",
        "video",
        "summary"
    ].includes(tag);
}
function getTabbableBoundary(root) {
    const allElements = [];
    function walk(el) {
        if (el instanceof HTMLElement) {
            allElements.push(el);
            if (el.shadowRoot && el.shadowRoot.mode === "open") walk(el.shadowRoot);
        }
        [
            ...el.querySelectorAll("*")
        ].map((e)=>walk(e)
        );
    }
    walk(root);
    const start = allElements.find((el)=>isTabbable(el)
    ) || null;
    const end = allElements.reverse().find((el)=>isTabbable(el)
    ) || null;
    return {
        start,
        end
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"ao9ex":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getOffset", ()=>getOffset
);
parcelHelpers.export(exports, "lockBodyScrolling", ()=>lockBodyScrolling
);
parcelHelpers.export(exports, "unlockBodyScrolling", ()=>unlockBodyScrolling
);
parcelHelpers.export(exports, "scrollIntoView", ()=>scrollIntoView
);
// src/internal/offset.ts
function getOffset(element, parent) {
    return {
        top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
        left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
    };
}
// src/internal/scroll.ts
var locks = /* @__PURE__ */ new Set();
function lockBodyScrolling(lockingEl) {
    locks.add(lockingEl);
    document.body.classList.add("sl-scroll-lock");
}
function unlockBodyScrolling(lockingEl) {
    locks.delete(lockingEl);
    if (locks.size === 0) document.body.classList.remove("sl-scroll-lock");
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
    const offset = getOffset(element, container);
    const offsetTop = offset.top + container.scrollTop;
    const offsetLeft = offset.left + container.scrollLeft;
    const minX = container.scrollLeft;
    const maxX = container.scrollLeft + container.offsetWidth;
    const minY = container.scrollTop;
    const maxY = container.scrollTop + container.offsetHeight;
    if (direction === "horizontal" || direction === "both") {
        if (offsetLeft < minX) container.scrollTo({
            left: offsetLeft,
            behavior
        });
        else if (offsetLeft + element.clientWidth > maxX) container.scrollTo({
            left: offsetLeft - container.offsetWidth + element.clientWidth,
            behavior
        });
    }
    if (direction === "vertical" || direction === "both") {
        if (offsetTop < minY) container.scrollTo({
            top: offsetTop,
            behavior
        });
        else if (offsetTop + element.clientHeight > maxY) container.scrollTo({
            top: offsetTop - container.offsetHeight + element.clientHeight,
            behavior
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jLpn7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dialog_styles_default", ()=>dialog_styles_default
);
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/dialog/dialog.styles.ts
var dialog_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
    transform: none;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
  }

  .dialog__close {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-x-large);
    padding: 0 var(--header-spacing);
  }

  .dialog__body {
    flex: 1 1 auto;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-left: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }
`;

},{"./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9cs7U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "component_styles_default", ()=>component_styles_default
);
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/styles/utility.styles.ts
var utility_styles_default = _chunk2VBMOEKGJs.r`
  .sl-scroll-lock {
    overflow: hidden !important;
  }

  .sl-toast-stack {
    position: fixed;
    top: 0;
    right: 0;
    z-index: var(--sl-z-index-toast);
    width: 28rem;
    max-width: 100%;
    max-height: 100%;
    overflow: auto;
  }

  .sl-toast-stack sl-alert {
    --box-shadow: var(--sl-shadow-large);
    margin: var(--sl-spacing-medium);
  }
`;
// src/styles/component.styles.ts
var component_styles_default = _chunk2VBMOEKGJs.r`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;
var style = document.createElement("style");
style.textContent = utility_styles_default.toString();
document.head.append(style);

},{"./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jJ4XN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$", ()=>$
) /**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */  /**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
parcelHelpers.export(exports, "y", ()=>y
);
parcelHelpers.export(exports, "b", ()=>b
);
parcelHelpers.export(exports, "w", ()=>w
);
parcelHelpers.export(exports, "o", ()=>o2
);
parcelHelpers.export(exports, "r", ()=>r2
);
parcelHelpers.export(exports, "s", ()=>s4
);
// node_modules/lit-html/lit-html.js
var t;
var i = globalThis.trustedTypes;
var s = i ? i.createPolicy("lit-html", {
    createHTML: (t4)=>t4
}) : void 0;
var e = `lit$${(Math.random() + "").slice(9)}$`;
var o = "?" + e;
var n = `<${o}>`;
var l = document;
var h = (t4 = "")=>l.createComment(t4)
;
var r = (t4)=>t4 === null || typeof t4 != "object" && typeof t4 != "function"
;
var d = Array.isArray;
var u = (t4)=>{
    var i4;
    return d(t4) || typeof ((i4 = t4) === null || i4 === void 0 ? void 0 : i4[Symbol.iterator]) == "function";
};
var c = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var a = />/g;
var f = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g;
var _ = /'/g;
var m = /"/g;
var g = /^(?:script|style|textarea)$/i;
var p = (t4)=>(i4, ...s7)=>({
            _$litType$: t4,
            strings: i4,
            values: s7
        })
;
var $ = p(1);
var y = p(2);
var b = Symbol.for("lit-noChange");
var w = Symbol.for("lit-nothing");
var T = /* @__PURE__ */ new WeakMap();
var x = (t4, i4, s7)=>{
    var e6, o7;
    const n7 = (e6 = s7 == null ? void 0 : s7.renderBefore) !== null && e6 !== void 0 ? e6 : i4;
    let l5 = n7._$litPart$;
    if (l5 === void 0) {
        const t5 = (o7 = s7 == null ? void 0 : s7.renderBefore) !== null && o7 !== void 0 ? o7 : null;
        n7._$litPart$ = l5 = new N(i4.insertBefore(h(), t5), t5, void 0, s7 != null ? s7 : {
        });
    }
    return l5._$AI(t4), l5;
};
var A = l.createTreeWalker(l, 129, null, false);
var C = (t4, i4)=>{
    const o7 = t4.length - 1, l5 = [];
    let h4, r6 = i4 === 2 ? "<svg>" : "", d2 = c;
    for(let i5 = 0; i5 < o7; i5++){
        const s7 = t4[i5];
        let o8, u3, p2 = -1, $2 = 0;
        for(; $2 < s7.length && (d2.lastIndex = $2, u3 = d2.exec(s7), u3 !== null);)$2 = d2.lastIndex, d2 === c ? u3[1] === "!--" ? d2 = v : u3[1] !== void 0 ? d2 = a : u3[2] !== void 0 ? (g.test(u3[2]) && (h4 = RegExp("</" + u3[2], "g")), d2 = f) : u3[3] !== void 0 && (d2 = f) : d2 === f ? u3[0] === ">" ? (d2 = h4 != null ? h4 : c, p2 = -1) : u3[1] === void 0 ? p2 = -2 : (p2 = d2.lastIndex - u3[2].length, o8 = u3[1], d2 = u3[3] === void 0 ? f : u3[3] === '"' ? m : _) : d2 === m || d2 === _ ? d2 = f : d2 === v || d2 === a ? d2 = c : (d2 = f, h4 = void 0);
        const y2 = d2 === f && t4[i5 + 1].startsWith("/>") ? " " : "";
        r6 += d2 === c ? s7 + n : p2 >= 0 ? (l5.push(o8), s7.slice(0, p2) + "$lit$" + s7.slice(p2) + e + y2) : s7 + e + (p2 === -2 ? (l5.push(void 0), i5) : y2);
    }
    const u2 = r6 + (t4[o7] || "<?>") + (i4 === 2 ? "</svg>" : "");
    if (!Array.isArray(t4) || !t4.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return [
        s !== void 0 ? s.createHTML(u2) : u2,
        l5
    ];
};
var E = class {
    constructor({ strings: t4 , _$litType$: s7  }, n7){
        let l5;
        this.parts = [];
        let r6 = 0, d2 = 0;
        const u2 = t4.length - 1, c2 = this.parts, [v2, a4] = C(t4, s7);
        if (this.el = E.createElement(v2, n7), A.currentNode = this.el.content, s7 === 2) {
            const t5 = this.el.content, i4 = t5.firstChild;
            i4.remove(), t5.append(...i4.childNodes);
        }
        for(; (l5 = A.nextNode()) !== null && c2.length < u2;){
            if (l5.nodeType === 1) {
                if (l5.hasAttributes()) {
                    const t5 = [];
                    for (const i4 of l5.getAttributeNames())if (i4.endsWith("$lit$") || i4.startsWith(e)) {
                        const s8 = a4[d2++];
                        if (t5.push(i4), s8 !== void 0) {
                            const t6 = l5.getAttribute(s8.toLowerCase() + "$lit$").split(e), i5 = /([.?@])?(.*)/.exec(s8);
                            c2.push({
                                type: 1,
                                index: r6,
                                name: i5[2],
                                strings: t6,
                                ctor: i5[1] === "." ? M : i5[1] === "?" ? H : i5[1] === "@" ? I : S
                            });
                        } else c2.push({
                            type: 6,
                            index: r6
                        });
                    }
                    for (const i41 of t5)l5.removeAttribute(i41);
                }
                if (g.test(l5.tagName)) {
                    const t5 = l5.textContent.split(e), s8 = t5.length - 1;
                    if (s8 > 0) {
                        l5.textContent = i ? i.emptyScript : "";
                        for(let i4 = 0; i4 < s8; i4++)l5.append(t5[i4], h()), A.nextNode(), c2.push({
                            type: 2,
                            index: ++r6
                        });
                        l5.append(t5[s8], h());
                    }
                }
            } else if (l5.nodeType === 8) {
                if (l5.data === o) c2.push({
                    type: 2,
                    index: r6
                });
                else {
                    let t5 = -1;
                    for(; (t5 = l5.data.indexOf(e, t5 + 1)) !== -1;)c2.push({
                        type: 7,
                        index: r6
                    }), t5 += e.length - 1;
                }
            }
            r6++;
        }
    }
    static createElement(t4, i4) {
        const s7 = l.createElement("template");
        return s7.innerHTML = t4, s7;
    }
};
function P(t4, i4, s7 = t4, e6) {
    var o7, n7, l5, h4;
    if (i4 === b) return i4;
    let d2 = e6 !== void 0 ? (o7 = s7._$Cl) === null || o7 === void 0 ? void 0 : o7[e6] : s7._$Cu;
    const u2 = r(i4) ? void 0 : i4._$litDirective$;
    return (d2 == null ? void 0 : d2.constructor) !== u2 && ((n7 = d2 == null ? void 0 : d2._$AO) === null || n7 === void 0 || n7.call(d2, false), u2 === void 0 ? d2 = void 0 : (d2 = new u2(t4), d2._$AT(t4, s7, e6)), e6 !== void 0 ? ((l5 = (h4 = s7)._$Cl) !== null && l5 !== void 0 ? l5 : h4._$Cl = [])[e6] = d2 : s7._$Cu = d2), d2 !== void 0 && (i4 = P(t4, d2._$AS(t4, i4.values), d2, e6)), i4;
}
var V = class {
    constructor(t4, i4){
        this.v = [], this._$AN = void 0, this._$AD = t4, this._$AM = i4;
    }
    get parentNode() {
        return this._$AM.parentNode;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    p(t4) {
        var i4;
        const { el: { content: s7  } , parts: e6  } = this._$AD, o7 = ((i4 = t4 == null ? void 0 : t4.creationScope) !== null && i4 !== void 0 ? i4 : l).importNode(s7, true);
        A.currentNode = o7;
        let n7 = A.nextNode(), h4 = 0, r6 = 0, d2 = e6[0];
        for(; d2 !== void 0;){
            if (h4 === d2.index) {
                let i5;
                d2.type === 2 ? i5 = new N(n7, n7.nextSibling, this, t4) : d2.type === 1 ? i5 = new d2.ctor(n7, d2.name, d2.strings, this, t4) : d2.type === 6 && (i5 = new L(n7, this, t4)), this.v.push(i5), d2 = e6[++r6];
            }
            h4 !== (d2 == null ? void 0 : d2.index) && (n7 = A.nextNode(), h4++);
        }
        return o7;
    }
    m(t4) {
        let i4 = 0;
        for (const s7 of this.v)s7 !== void 0 && (s7.strings !== void 0 ? (s7._$AI(t4, s7, i4), i4 += s7.strings.length - 2) : s7._$AI(t4[i4])), i4++;
    }
};
var N = class {
    constructor(t4, i4, s7, e6){
        var o7;
        this.type = 2, this._$AH = w, this._$AN = void 0, this._$AA = t4, this._$AB = i4, this._$AM = s7, this.options = e6, this._$Cg = (o7 = e6 == null ? void 0 : e6.isConnected) === null || o7 === void 0 || o7;
    }
    get _$AU() {
        var t4, i4;
        return (i4 = (t4 = this._$AM) === null || t4 === void 0 ? void 0 : t4._$AU) !== null && i4 !== void 0 ? i4 : this._$Cg;
    }
    get parentNode() {
        let t4 = this._$AA.parentNode;
        const i4 = this._$AM;
        return i4 !== void 0 && t4.nodeType === 11 && (t4 = i4.parentNode), t4;
    }
    get startNode() {
        return this._$AA;
    }
    get endNode() {
        return this._$AB;
    }
    _$AI(t4, i4 = this) {
        t4 = P(this, t4, i4), r(t4) ? t4 === w || t4 == null || t4 === "" ? (this._$AH !== w && this._$AR(), this._$AH = w) : t4 !== this._$AH && t4 !== b && this.$(t4) : t4._$litType$ !== void 0 ? this.T(t4) : t4.nodeType !== void 0 ? this.S(t4) : u(t4) ? this.A(t4) : this.$(t4);
    }
    M(t4, i4 = this._$AB) {
        return this._$AA.parentNode.insertBefore(t4, i4);
    }
    S(t4) {
        this._$AH !== t4 && (this._$AR(), this._$AH = this.M(t4));
    }
    $(t4) {
        this._$AH !== w && r(this._$AH) ? this._$AA.nextSibling.data = t4 : this.S(l.createTextNode(t4)), this._$AH = t4;
    }
    T(t4) {
        var i4;
        const { values: s7 , _$litType$: e6  } = t4, o7 = typeof e6 == "number" ? this._$AC(t4) : (e6.el === void 0 && (e6.el = E.createElement(e6.h, this.options)), e6);
        if (((i4 = this._$AH) === null || i4 === void 0 ? void 0 : i4._$AD) === o7) this._$AH.m(s7);
        else {
            const t5 = new V(o7, this), i5 = t5.p(this.options);
            t5.m(s7), this.S(i5), this._$AH = t5;
        }
    }
    _$AC(t4) {
        let i4 = T.get(t4.strings);
        return i4 === void 0 && T.set(t4.strings, i4 = new E(t4)), i4;
    }
    A(t4) {
        d(this._$AH) || (this._$AH = [], this._$AR());
        const i4 = this._$AH;
        let s7, e6 = 0;
        for (const o7 of t4)e6 === i4.length ? i4.push(s7 = new N(this.M(h()), this.M(h()), this, this.options)) : s7 = i4[e6], s7._$AI(o7), e6++;
        e6 < i4.length && (this._$AR(s7 && s7._$AB.nextSibling, e6), i4.length = e6);
    }
    _$AR(t4 = this._$AA.nextSibling, i4) {
        var s7;
        for((s7 = this._$AP) === null || s7 === void 0 || s7.call(this, false, true, i4); t4 && t4 !== this._$AB;){
            const i5 = t4.nextSibling;
            t4.remove(), t4 = i5;
        }
    }
    setConnected(t4) {
        var i4;
        this._$AM === void 0 && (this._$Cg = t4, (i4 = this._$AP) === null || i4 === void 0 || i4.call(this, t4));
    }
};
var S = class {
    constructor(t4, i4, s7, e6, o7){
        this.type = 1, this._$AH = w, this._$AN = void 0, this.element = t4, this.name = i4, this._$AM = e6, this.options = o7, s7.length > 2 || s7[0] !== "" || s7[1] !== "" ? (this._$AH = Array(s7.length - 1).fill(new String()), this.strings = s7) : this._$AH = w;
    }
    get tagName() {
        return this.element.tagName;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t4, i4 = this, s7, e6) {
        const o7 = this.strings;
        let n7 = false;
        if (o7 === void 0) t4 = P(this, t4, i4, 0), n7 = !r(t4) || t4 !== this._$AH && t4 !== b, n7 && (this._$AH = t4);
        else {
            const e7 = t4;
            let l5, h4;
            for(t4 = o7[0], l5 = 0; l5 < o7.length - 1; l5++)h4 = P(this, e7[s7 + l5], i4, l5), h4 === b && (h4 = this._$AH[l5]), n7 || (n7 = !r(h4) || h4 !== this._$AH[l5]), h4 === w ? t4 = w : t4 !== w && (t4 += (h4 != null ? h4 : "") + o7[l5 + 1]), this._$AH[l5] = h4;
        }
        n7 && !e6 && this.k(t4);
    }
    k(t4) {
        t4 === w ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t4 != null ? t4 : "");
    }
};
var M = class extends S {
    constructor(){
        super(...arguments), this.type = 3;
    }
    k(t4) {
        this.element[this.name] = t4 === w ? void 0 : t4;
    }
};
var k = i ? i.emptyScript : "";
var H = class extends S {
    constructor(){
        super(...arguments), this.type = 4;
    }
    k(t4) {
        t4 && t4 !== w ? this.element.setAttribute(this.name, k) : this.element.removeAttribute(this.name);
    }
};
var I = class extends S {
    constructor(t4, i4, s7, e6, o7){
        super(t4, i4, s7, e6, o7), this.type = 5;
    }
    _$AI(t4, i4 = this) {
        var s7;
        if ((t4 = (s7 = P(this, t4, i4, 0)) !== null && s7 !== void 0 ? s7 : w) === b) return;
        const e6 = this._$AH, o7 = t4 === w && e6 !== w || t4.capture !== e6.capture || t4.once !== e6.once || t4.passive !== e6.passive, n7 = t4 !== w && (e6 === w || o7);
        o7 && this.element.removeEventListener(this.name, this, e6), n7 && this.element.addEventListener(this.name, this, t4), this._$AH = t4;
    }
    handleEvent(t4) {
        var i4, s7;
        typeof this._$AH == "function" ? this._$AH.call((s7 = (i4 = this.options) === null || i4 === void 0 ? void 0 : i4.host) !== null && s7 !== void 0 ? s7 : this.element, t4) : this._$AH.handleEvent(t4);
    }
};
var L = class {
    constructor(t4, i4, s7){
        this.element = t4, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s7;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t4) {
        P(this, t4);
    }
};
var z = window.litHtmlPolyfillSupport;
z == null || z(E, N), ((t = globalThis.litHtmlVersions) !== null && t !== void 0 ? t : globalThis.litHtmlVersions = []).push("2.1.0");
// node_modules/lit-element/node_modules/@lit/reactive-element/css-tag.js
var t2 = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var e2 = Symbol();
var n2 = /* @__PURE__ */ new Map();
var s2 = class {
    constructor(t4, n7){
        if (this._$cssResult$ = true, n7 !== e2) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t4;
    }
    get styleSheet() {
        let e6 = n2.get(this.cssText);
        return t2 && e6 === void 0 && (n2.set(this.cssText, e6 = new CSSStyleSheet()), e6.replaceSync(this.cssText)), e6;
    }
    toString() {
        return this.cssText;
    }
};
var o2 = (t4)=>new s2(typeof t4 == "string" ? t4 : t4 + "", e2)
;
var r2 = (t4, ...n7)=>{
    const o7 = t4.length === 1 ? t4[0] : n7.reduce((e6, n8, s7)=>e6 + ((t5)=>{
            if (t5._$cssResult$ === true) return t5.cssText;
            if (typeof t5 == "number") return t5;
            throw Error("Value passed to 'css' function must be a 'css' function result: " + t5 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
        })(n8) + t4[s7 + 1]
    , t4[0]);
    return new s2(o7, e2);
};
var i2 = (e6, n7)=>{
    t2 ? e6.adoptedStyleSheets = n7.map((t4)=>t4 instanceof CSSStyleSheet ? t4 : t4.styleSheet
    ) : n7.forEach((t4)=>{
        const n8 = document.createElement("style"), s7 = window.litNonce;
        s7 !== void 0 && n8.setAttribute("nonce", s7), n8.textContent = t4.cssText, e6.appendChild(n8);
    });
};
var S2 = t2 ? (t4)=>t4
 : (t4)=>t4 instanceof CSSStyleSheet ? ((t5)=>{
        let e6 = "";
        for (const n7 of t5.cssRules)e6 += n7.cssText;
        return o2(e6);
    })(t4) : t4
;
// node_modules/lit-element/node_modules/@lit/reactive-element/reactive-element.js
var s3;
var e3 = window.trustedTypes;
var r3 = e3 ? e3.emptyScript : "";
var h2 = window.reactiveElementPolyfillSupport;
var o3 = {
    toAttribute (t4, i4) {
        switch(i4){
            case Boolean:
                t4 = t4 ? r3 : null;
                break;
            case Object:
            case Array:
                t4 = t4 == null ? t4 : JSON.stringify(t4);
        }
        return t4;
    },
    fromAttribute (t4, i4) {
        let s7 = t4;
        switch(i4){
            case Boolean:
                s7 = t4 !== null;
                break;
            case Number:
                s7 = t4 === null ? null : Number(t4);
                break;
            case Object:
            case Array:
                try {
                    s7 = JSON.parse(t4);
                } catch (t5) {
                    s7 = null;
                }
        }
        return s7;
    }
};
var n3 = (t4, i4)=>i4 !== t4 && (i4 == i4 || t4 == t4)
;
var l2 = {
    attribute: true,
    type: String,
    converter: o3,
    reflect: false,
    hasChanged: n3
};
var a2 = class extends HTMLElement {
    constructor(){
        super(), this._$Et = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$Ei = null, this.o();
    }
    static addInitializer(t4) {
        var i4;
        (i4 = this.l) !== null && i4 !== void 0 || (this.l = []), this.l.push(t4);
    }
    static get observedAttributes() {
        this.finalize();
        const t4 = [];
        return this.elementProperties.forEach((i4, s7)=>{
            const e6 = this._$Eh(s7, i4);
            e6 !== void 0 && (this._$Eu.set(e6, s7), t4.push(e6));
        }), t4;
    }
    static createProperty(t4, i4 = l2) {
        if (i4.state && (i4.attribute = false), this.finalize(), this.elementProperties.set(t4, i4), !i4.noAccessor && !this.prototype.hasOwnProperty(t4)) {
            const s7 = typeof t4 == "symbol" ? Symbol() : "__" + t4, e6 = this.getPropertyDescriptor(t4, s7, i4);
            e6 !== void 0 && Object.defineProperty(this.prototype, t4, e6);
        }
    }
    static getPropertyDescriptor(t4, i4, s7) {
        return {
            get () {
                return this[i4];
            },
            set (e6) {
                const r6 = this[t4];
                this[i4] = e6, this.requestUpdate(t4, r6, s7);
            },
            configurable: true,
            enumerable: true
        };
    }
    static getPropertyOptions(t4) {
        return this.elementProperties.get(t4) || l2;
    }
    static finalize() {
        if (this.hasOwnProperty("finalized")) return false;
        this.finalized = true;
        const t4 = Object.getPrototypeOf(this);
        if (t4.finalize(), this.elementProperties = new Map(t4.elementProperties), this._$Eu = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
            const t5 = this.properties, i4 = [
                ...Object.getOwnPropertyNames(t5),
                ...Object.getOwnPropertySymbols(t5)
            ];
            for (const s7 of i4)this.createProperty(s7, t5[s7]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), true;
    }
    static finalizeStyles(i4) {
        const s7 = [];
        if (Array.isArray(i4)) {
            const e6 = new Set(i4.flat(1 / 0).reverse());
            for (const i5 of e6)s7.unshift(S2(i5));
        } else i4 !== void 0 && s7.push(S2(i4));
        return s7;
    }
    static _$Eh(t4, i4) {
        const s7 = i4.attribute;
        return s7 === false ? void 0 : typeof s7 == "string" ? s7 : typeof t4 == "string" ? t4.toLowerCase() : void 0;
    }
    o() {
        var t4;
        this._$Ep = new Promise((t5)=>this.enableUpdating = t5
        ), this._$AL = /* @__PURE__ */ new Map(), this._$Em(), this.requestUpdate(), (t4 = this.constructor.l) === null || t4 === void 0 || t4.forEach((t5)=>t5(this)
        );
    }
    addController(t4) {
        var i4, s7;
        ((i4 = this._$Eg) !== null && i4 !== void 0 ? i4 : this._$Eg = []).push(t4), this.renderRoot !== void 0 && this.isConnected && ((s7 = t4.hostConnected) === null || s7 === void 0 || s7.call(t4));
    }
    removeController(t4) {
        var i4;
        (i4 = this._$Eg) === null || i4 === void 0 || i4.splice(this._$Eg.indexOf(t4) >>> 0, 1);
    }
    _$Em() {
        this.constructor.elementProperties.forEach((t4, i4)=>{
            this.hasOwnProperty(i4) && (this._$Et.set(i4, this[i4]), delete this[i4]);
        });
    }
    createRenderRoot() {
        var t4;
        const s7 = (t4 = this.shadowRoot) !== null && t4 !== void 0 ? t4 : this.attachShadow(this.constructor.shadowRootOptions);
        return i2(s7, this.constructor.elementStyles), s7;
    }
    connectedCallback() {
        var t4;
        this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t4 = this._$Eg) === null || t4 === void 0 || t4.forEach((t5)=>{
            var i4;
            return (i4 = t5.hostConnected) === null || i4 === void 0 ? void 0 : i4.call(t5);
        });
    }
    enableUpdating(t4) {
    }
    disconnectedCallback() {
        var t4;
        (t4 = this._$Eg) === null || t4 === void 0 || t4.forEach((t5)=>{
            var i4;
            return (i4 = t5.hostDisconnected) === null || i4 === void 0 ? void 0 : i4.call(t5);
        });
    }
    attributeChangedCallback(t4, i4, s7) {
        this._$AK(t4, s7);
    }
    _$ES(t4, i4, s7 = l2) {
        var e6, r6;
        const h4 = this.constructor._$Eh(t4, s7);
        if (h4 !== void 0 && s7.reflect === true) {
            const n7 = ((r6 = (e6 = s7.converter) === null || e6 === void 0 ? void 0 : e6.toAttribute) !== null && r6 !== void 0 ? r6 : o3.toAttribute)(i4, s7.type);
            this._$Ei = t4, n7 == null ? this.removeAttribute(h4) : this.setAttribute(h4, n7), this._$Ei = null;
        }
    }
    _$AK(t4, i4) {
        var s7, e6, r6;
        const h4 = this.constructor, n7 = h4._$Eu.get(t4);
        if (n7 !== void 0 && this._$Ei !== n7) {
            const t5 = h4.getPropertyOptions(n7), l5 = t5.converter, a4 = (r6 = (e6 = (s7 = l5) === null || s7 === void 0 ? void 0 : s7.fromAttribute) !== null && e6 !== void 0 ? e6 : typeof l5 == "function" ? l5 : null) !== null && r6 !== void 0 ? r6 : o3.fromAttribute;
            this._$Ei = n7, this[n7] = a4(i4, t5.type), this._$Ei = null;
        }
    }
    requestUpdate(t4, i4, s7) {
        let e6 = true;
        t4 !== void 0 && (((s7 = s7 || this.constructor.getPropertyOptions(t4)).hasChanged || n3)(this[t4], i4) ? (this._$AL.has(t4) || this._$AL.set(t4, i4), s7.reflect === true && this._$Ei !== t4 && (this._$E_ === void 0 && (this._$E_ = /* @__PURE__ */ new Map()), this._$E_.set(t4, s7))) : e6 = false), !this.isUpdatePending && e6 && (this._$Ep = this._$EC());
    }
    async _$EC() {
        this.isUpdatePending = true;
        try {
            await this._$Ep;
        } catch (t5) {
            Promise.reject(t5);
        }
        const t4 = this.scheduleUpdate();
        return t4 != null && await t4, !this.isUpdatePending;
    }
    scheduleUpdate() {
        return this.performUpdate();
    }
    performUpdate() {
        var t4;
        if (!this.isUpdatePending) return;
        this.hasUpdated, this._$Et && (this._$Et.forEach((t5, i5)=>this[i5] = t5
        ), this._$Et = void 0);
        let i4 = false;
        const s7 = this._$AL;
        try {
            i4 = this.shouldUpdate(s7), i4 ? (this.willUpdate(s7), (t4 = this._$Eg) === null || t4 === void 0 || t4.forEach((t5)=>{
                var i5;
                return (i5 = t5.hostUpdate) === null || i5 === void 0 ? void 0 : i5.call(t5);
            }), this.update(s7)) : this._$EU();
        } catch (t5) {
            throw i4 = false, this._$EU(), t5;
        }
        i4 && this._$AE(s7);
    }
    willUpdate(t4) {
    }
    _$AE(t4) {
        var i4;
        (i4 = this._$Eg) === null || i4 === void 0 || i4.forEach((t5)=>{
            var i5;
            return (i5 = t5.hostUpdated) === null || i5 === void 0 ? void 0 : i5.call(t5);
        }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t4)), this.updated(t4);
    }
    _$EU() {
        this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
        return this.getUpdateComplete();
    }
    getUpdateComplete() {
        return this._$Ep;
    }
    shouldUpdate(t4) {
        return true;
    }
    update(t4) {
        this._$E_ !== void 0 && (this._$E_.forEach((t5, i4)=>this._$ES(i4, this[i4], t5)
        ), this._$E_ = void 0), this._$EU();
    }
    updated(t4) {
    }
    firstUpdated(t4) {
    }
};
a2.finalized = true, a2.elementProperties = /* @__PURE__ */ new Map(), a2.elementStyles = [], a2.shadowRootOptions = {
    mode: "open"
}, h2 == null || h2({
    ReactiveElement: a2
}), ((s3 = globalThis.reactiveElementVersions) !== null && s3 !== void 0 ? s3 : globalThis.reactiveElementVersions = []).push("1.1.0");
// node_modules/lit-element/lit-element.js
var l3;
var o4;
var s4 = class extends a2 {
    constructor(){
        super(...arguments), this.renderOptions = {
            host: this
        }, this._$Dt = void 0;
    }
    createRenderRoot() {
        var t4, e6;
        const i4 = super.createRenderRoot();
        return (t4 = (e6 = this.renderOptions).renderBefore) !== null && t4 !== void 0 || (e6.renderBefore = i4.firstChild), i4;
    }
    update(t4) {
        const i4 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t4), this._$Dt = x(i4, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
        var t4;
        super.connectedCallback(), (t4 = this._$Dt) === null || t4 === void 0 || t4.setConnected(true);
    }
    disconnectedCallback() {
        var t4;
        super.disconnectedCallback(), (t4 = this._$Dt) === null || t4 === void 0 || t4.setConnected(false);
    }
    render() {
        return b;
    }
};
s4.finalized = true, s4._$litElement$ = true, (l3 = globalThis.litElementHydrateSupport) === null || l3 === void 0 || l3.call(globalThis, {
    LitElement: s4
});
var n4 = globalThis.litElementPolyfillSupport;
n4 == null || n4({
    LitElement: s4
});
((o4 = globalThis.litElementVersions) !== null && o4 !== void 0 ? o4 : globalThis.litElementVersions = []).push("3.1.0");
// node_modules/lit/node_modules/@lit/reactive-element/css-tag.js
var t3 = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var e4 = Symbol();
var n5 = /* @__PURE__ */ new Map();
var s5 = class {
    constructor(t4, n7){
        if (this._$cssResult$ = true, n7 !== e4) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t4;
    }
    get styleSheet() {
        let e6 = n5.get(this.cssText);
        return t3 && e6 === void 0 && (n5.set(this.cssText, e6 = new CSSStyleSheet()), e6.replaceSync(this.cssText)), e6;
    }
    toString() {
        return this.cssText;
    }
};
var o5 = (t4)=>new s5(typeof t4 == "string" ? t4 : t4 + "", e4)
;
var i3 = (e6, n7)=>{
    t3 ? e6.adoptedStyleSheets = n7.map((t4)=>t4 instanceof CSSStyleSheet ? t4 : t4.styleSheet
    ) : n7.forEach((t4)=>{
        const n8 = document.createElement("style"), s7 = window.litNonce;
        s7 !== void 0 && n8.setAttribute("nonce", s7), n8.textContent = t4.cssText, e6.appendChild(n8);
    });
};
var S3 = t3 ? (t4)=>t4
 : (t4)=>t4 instanceof CSSStyleSheet ? ((t5)=>{
        let e6 = "";
        for (const n7 of t5.cssRules)e6 += n7.cssText;
        return o5(e6);
    })(t4) : t4
;
// node_modules/lit/node_modules/@lit/reactive-element/reactive-element.js
var s6;
var e5 = window.trustedTypes;
var r5 = e5 ? e5.emptyScript : "";
var h3 = window.reactiveElementPolyfillSupport;
var o6 = {
    toAttribute (t4, i4) {
        switch(i4){
            case Boolean:
                t4 = t4 ? r5 : null;
                break;
            case Object:
            case Array:
                t4 = t4 == null ? t4 : JSON.stringify(t4);
        }
        return t4;
    },
    fromAttribute (t4, i4) {
        let s7 = t4;
        switch(i4){
            case Boolean:
                s7 = t4 !== null;
                break;
            case Number:
                s7 = t4 === null ? null : Number(t4);
                break;
            case Object:
            case Array:
                try {
                    s7 = JSON.parse(t4);
                } catch (t5) {
                    s7 = null;
                }
        }
        return s7;
    }
};
var n6 = (t4, i4)=>i4 !== t4 && (i4 == i4 || t4 == t4)
;
var l4 = {
    attribute: true,
    type: String,
    converter: o6,
    reflect: false,
    hasChanged: n6
};
var a3 = class extends HTMLElement {
    constructor(){
        super(), this._$Et = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$Ei = null, this.o();
    }
    static addInitializer(t4) {
        var i4;
        (i4 = this.l) !== null && i4 !== void 0 || (this.l = []), this.l.push(t4);
    }
    static get observedAttributes() {
        this.finalize();
        const t4 = [];
        return this.elementProperties.forEach((i4, s7)=>{
            const e6 = this._$Eh(s7, i4);
            e6 !== void 0 && (this._$Eu.set(e6, s7), t4.push(e6));
        }), t4;
    }
    static createProperty(t4, i4 = l4) {
        if (i4.state && (i4.attribute = false), this.finalize(), this.elementProperties.set(t4, i4), !i4.noAccessor && !this.prototype.hasOwnProperty(t4)) {
            const s7 = typeof t4 == "symbol" ? Symbol() : "__" + t4, e6 = this.getPropertyDescriptor(t4, s7, i4);
            e6 !== void 0 && Object.defineProperty(this.prototype, t4, e6);
        }
    }
    static getPropertyDescriptor(t4, i4, s7) {
        return {
            get () {
                return this[i4];
            },
            set (e6) {
                const r6 = this[t4];
                this[i4] = e6, this.requestUpdate(t4, r6, s7);
            },
            configurable: true,
            enumerable: true
        };
    }
    static getPropertyOptions(t4) {
        return this.elementProperties.get(t4) || l4;
    }
    static finalize() {
        if (this.hasOwnProperty("finalized")) return false;
        this.finalized = true;
        const t4 = Object.getPrototypeOf(this);
        if (t4.finalize(), this.elementProperties = new Map(t4.elementProperties), this._$Eu = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
            const t5 = this.properties, i4 = [
                ...Object.getOwnPropertyNames(t5),
                ...Object.getOwnPropertySymbols(t5)
            ];
            for (const s7 of i4)this.createProperty(s7, t5[s7]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), true;
    }
    static finalizeStyles(i4) {
        const s7 = [];
        if (Array.isArray(i4)) {
            const e6 = new Set(i4.flat(1 / 0).reverse());
            for (const i5 of e6)s7.unshift(S3(i5));
        } else i4 !== void 0 && s7.push(S3(i4));
        return s7;
    }
    static _$Eh(t4, i4) {
        const s7 = i4.attribute;
        return s7 === false ? void 0 : typeof s7 == "string" ? s7 : typeof t4 == "string" ? t4.toLowerCase() : void 0;
    }
    o() {
        var t4;
        this._$Ep = new Promise((t5)=>this.enableUpdating = t5
        ), this._$AL = /* @__PURE__ */ new Map(), this._$Em(), this.requestUpdate(), (t4 = this.constructor.l) === null || t4 === void 0 || t4.forEach((t5)=>t5(this)
        );
    }
    addController(t4) {
        var i4, s7;
        ((i4 = this._$Eg) !== null && i4 !== void 0 ? i4 : this._$Eg = []).push(t4), this.renderRoot !== void 0 && this.isConnected && ((s7 = t4.hostConnected) === null || s7 === void 0 || s7.call(t4));
    }
    removeController(t4) {
        var i4;
        (i4 = this._$Eg) === null || i4 === void 0 || i4.splice(this._$Eg.indexOf(t4) >>> 0, 1);
    }
    _$Em() {
        this.constructor.elementProperties.forEach((t4, i4)=>{
            this.hasOwnProperty(i4) && (this._$Et.set(i4, this[i4]), delete this[i4]);
        });
    }
    createRenderRoot() {
        var t4;
        const s7 = (t4 = this.shadowRoot) !== null && t4 !== void 0 ? t4 : this.attachShadow(this.constructor.shadowRootOptions);
        return i3(s7, this.constructor.elementStyles), s7;
    }
    connectedCallback() {
        var t4;
        this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t4 = this._$Eg) === null || t4 === void 0 || t4.forEach((t5)=>{
            var i4;
            return (i4 = t5.hostConnected) === null || i4 === void 0 ? void 0 : i4.call(t5);
        });
    }
    enableUpdating(t4) {
    }
    disconnectedCallback() {
        var t4;
        (t4 = this._$Eg) === null || t4 === void 0 || t4.forEach((t5)=>{
            var i4;
            return (i4 = t5.hostDisconnected) === null || i4 === void 0 ? void 0 : i4.call(t5);
        });
    }
    attributeChangedCallback(t4, i4, s7) {
        this._$AK(t4, s7);
    }
    _$ES(t4, i4, s7 = l4) {
        var e6, r6;
        const h4 = this.constructor._$Eh(t4, s7);
        if (h4 !== void 0 && s7.reflect === true) {
            const n7 = ((r6 = (e6 = s7.converter) === null || e6 === void 0 ? void 0 : e6.toAttribute) !== null && r6 !== void 0 ? r6 : o6.toAttribute)(i4, s7.type);
            this._$Ei = t4, n7 == null ? this.removeAttribute(h4) : this.setAttribute(h4, n7), this._$Ei = null;
        }
    }
    _$AK(t4, i4) {
        var s7, e6, r6;
        const h4 = this.constructor, n7 = h4._$Eu.get(t4);
        if (n7 !== void 0 && this._$Ei !== n7) {
            const t5 = h4.getPropertyOptions(n7), l5 = t5.converter, a4 = (r6 = (e6 = (s7 = l5) === null || s7 === void 0 ? void 0 : s7.fromAttribute) !== null && e6 !== void 0 ? e6 : typeof l5 == "function" ? l5 : null) !== null && r6 !== void 0 ? r6 : o6.fromAttribute;
            this._$Ei = n7, this[n7] = a4(i4, t5.type), this._$Ei = null;
        }
    }
    requestUpdate(t4, i4, s7) {
        let e6 = true;
        t4 !== void 0 && (((s7 = s7 || this.constructor.getPropertyOptions(t4)).hasChanged || n6)(this[t4], i4) ? (this._$AL.has(t4) || this._$AL.set(t4, i4), s7.reflect === true && this._$Ei !== t4 && (this._$E_ === void 0 && (this._$E_ = /* @__PURE__ */ new Map()), this._$E_.set(t4, s7))) : e6 = false), !this.isUpdatePending && e6 && (this._$Ep = this._$EC());
    }
    async _$EC() {
        this.isUpdatePending = true;
        try {
            await this._$Ep;
        } catch (t5) {
            Promise.reject(t5);
        }
        const t4 = this.scheduleUpdate();
        return t4 != null && await t4, !this.isUpdatePending;
    }
    scheduleUpdate() {
        return this.performUpdate();
    }
    performUpdate() {
        var t4;
        if (!this.isUpdatePending) return;
        this.hasUpdated, this._$Et && (this._$Et.forEach((t5, i5)=>this[i5] = t5
        ), this._$Et = void 0);
        let i4 = false;
        const s7 = this._$AL;
        try {
            i4 = this.shouldUpdate(s7), i4 ? (this.willUpdate(s7), (t4 = this._$Eg) === null || t4 === void 0 || t4.forEach((t5)=>{
                var i5;
                return (i5 = t5.hostUpdate) === null || i5 === void 0 ? void 0 : i5.call(t5);
            }), this.update(s7)) : this._$EU();
        } catch (t5) {
            throw i4 = false, this._$EU(), t5;
        }
        i4 && this._$AE(s7);
    }
    willUpdate(t4) {
    }
    _$AE(t4) {
        var i4;
        (i4 = this._$Eg) === null || i4 === void 0 || i4.forEach((t5)=>{
            var i5;
            return (i5 = t5.hostUpdated) === null || i5 === void 0 ? void 0 : i5.call(t5);
        }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t4)), this.updated(t4);
    }
    _$EU() {
        this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
        return this.getUpdateComplete();
    }
    getUpdateComplete() {
        return this._$Ep;
    }
    shouldUpdate(t4) {
        return true;
    }
    update(t4) {
        this._$E_ !== void 0 && (this._$E_.forEach((t5, i4)=>this._$ES(i4, this[i4], t5)
        ), this._$E_ = void 0), this._$EU();
    }
    updated(t4) {
    }
    firstUpdated(t4) {
    }
};
a3.finalized = true, a3.elementProperties = /* @__PURE__ */ new Map(), a3.elementStyles = [], a3.shadowRootOptions = {
    mode: "open"
}, h3 == null || h3({
    ReactiveElement: a3
}), ((s6 = globalThis.reactiveElementVersions) !== null && s6 !== void 0 ? s6 : globalThis.reactiveElementVersions = []).push("1.1.0");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"akO45":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HasSlotController", ()=>HasSlotController
);
parcelHelpers.export(exports, "getTextContent", ()=>getTextContent
);
// src/internal/slot.ts
var HasSlotController = class {
    constructor(host, ...slotNames){
        this.slotNames = [];
        (this.host = host).addController(this);
        this.slotNames = slotNames;
        this.handleSlotChange = this.handleSlotChange.bind(this);
    }
    hasDefaultSlot() {
        return [
            ...this.host.childNodes
        ].some((node)=>{
            if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") return true;
            if (node.nodeType === node.ELEMENT_NODE) {
                const el = node;
                if (!el.hasAttribute("slot")) return true;
            }
            return false;
        });
    }
    hasNamedSlot(name) {
        return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
    }
    test(slotName) {
        return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
    }
    hostConnected() {
        this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
    }
    hostDisconnected() {
        this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
    }
    handleSlotChange(event) {
        var _a;
        const slot = event.target;
        if (this.slotNames.includes("[default]") && !slot.name || slot.name && ((_a = this.slotNames) == null ? void 0 : _a.includes(slot.name))) this.host.requestUpdate();
    }
};
function getTextContent(slot) {
    const nodes = slot ? slot.assignedNodes({
        flatten: true
    }) : [];
    let text = "";
    [
        ...nodes
    ].map((node)=>{
        if (node.nodeType === Node.TEXT_NODE) text += node.textContent;
    });
    return text;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d40Fl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "animateTo", ()=>animateTo
);
parcelHelpers.export(exports, "parseDuration", ()=>parseDuration
);
parcelHelpers.export(exports, "stopAnimations", ()=>stopAnimations
);
parcelHelpers.export(exports, "shimKeyframesHeightAuto", ()=>shimKeyframesHeightAuto
);
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/internal/animate.ts
function animateTo(el, keyframes, options) {
    return new Promise(async (resolve)=>{
        if ((options == null ? void 0 : options.duration) === Infinity) throw new Error("Promise-based animations must be finite.");
        const animation = el.animate(keyframes, _chunk4M3HOXYQJs.__spreadProps(_chunk4M3HOXYQJs.__spreadValues({
        }, options), {
            duration: prefersReducedMotion() ? 0 : options.duration
        }));
        animation.addEventListener("cancel", resolve, {
            once: true
        });
        animation.addEventListener("finish", resolve, {
            once: true
        });
    });
}
function parseDuration(delay) {
    delay = (delay + "").toLowerCase();
    if (delay.indexOf("ms") > -1) return parseFloat(delay);
    if (delay.indexOf("s") > -1) return parseFloat(delay) * 1000;
    return parseFloat(delay);
}
function prefersReducedMotion() {
    const query = window.matchMedia("(prefers-reduced-motion: reduce)");
    return query == null ? void 0 : query.matches;
}
function stopAnimations(el) {
    return Promise.all(el.getAnimations().map((animation)=>{
        return new Promise((resolve)=>{
            const handleAnimationEvent = requestAnimationFrame(resolve);
            animation.addEventListener("cancel", ()=>handleAnimationEvent
            , {
                once: true
            });
            animation.addEventListener("finish", ()=>handleAnimationEvent
            , {
                once: true
            });
            animation.cancel();
        });
    }));
}
function shimKeyframesHeightAuto(keyframes, calculatedHeight) {
    return keyframes.map((keyframe)=>Object.assign({
        }, keyframe, {
            height: keyframe.height === "auto" ? `${calculatedHeight}px` : keyframe.height
        })
    );
}

},{"./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"BRuiO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__spreadValues", ()=>__spreadValues
);
parcelHelpers.export(exports, "__spreadProps", ()=>__spreadProps
);
parcelHelpers.export(exports, "__commonJS", ()=>__commonJS
);
parcelHelpers.export(exports, "__export", ()=>__export
);
parcelHelpers.export(exports, "__toESM", ()=>__toESM
);
parcelHelpers.export(exports, "__decorateClass", ()=>__decorateClass
);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {
    }))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(b))if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b))
;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    })
;
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {
            }
        }).exports, mod), mod.exports;
    }
;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module, copyDefault, desc)=>{
    if (module && typeof module === "object" || typeof module === "function") {
        for (let key of __getOwnPropNames(module))if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default")) __defProp(target, key, {
            get: ()=>module[key]
            ,
            enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable
        });
    }
    return target;
};
var __toESM = (module, isNodeMode)=>{
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {
    }, "default", !isNodeMode && module && module.__esModule ? {
        get: ()=>module.default
        ,
        enumerable: true
    } : {
        value: module,
        enumerable: true
    })), module);
};
var __decorateClass = (decorators, target, key, kind)=>{
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for(var i = decorators.length - 1, decorator; i >= 0; i--)if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4h4P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setDefaultAnimation", ()=>setDefaultAnimation
);
parcelHelpers.export(exports, "setAnimation", ()=>setAnimation
);
parcelHelpers.export(exports, "getAnimation", ()=>getAnimation
);
// src/utilities/animation-registry.ts
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
    return animation != null ? animation : {
        keyframes: [],
        options: {
            duration: 0
        }
    };
}
function setDefaultAnimation(animationName, animation) {
    defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function setAnimation(el, animationName, animation) {
    customAnimationRegistry.set(el, Object.assign({
    }, customAnimationRegistry.get(el), {
        [animationName]: ensureAnimation(animation)
    }));
}
function getAnimation(el, animationName) {
    const customAnimation = customAnimationRegistry.get(el);
    if (customAnimation && customAnimation[animationName]) return customAnimation[animationName];
    const defaultAnimation = defaultAnimationRegistry.get(animationName);
    if (defaultAnimation) return defaultAnimation;
    return {
        keyframes: [],
        options: {
            duration: 0
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9o2tn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "o", ()=>o
) /**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
var _chunk2JQPDYNAJs = require("./chunk.2JQPDYNA.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// node_modules/lit-html/directives/class-map.js
var o = _chunk2JQPDYNAJs.e(class extends _chunk2JQPDYNAJs.i {
    constructor(t2){
        var i2;
        if (super(t2), t2.type !== _chunk2JQPDYNAJs.t.ATTRIBUTE || t2.name !== "class" || ((i2 = t2.strings) === null || i2 === void 0 ? void 0 : i2.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
    render(t2) {
        return " " + Object.keys(t2).filter((i2)=>t2[i2]
        ).join(" ") + " ";
    }
    update(i2, [s]) {
        var r, o2;
        if (this.st === void 0) {
            this.st = /* @__PURE__ */ new Set(), i2.strings !== void 0 && (this.et = new Set(i2.strings.join(" ").split(/\s/).filter((t2)=>t2 !== ""
            )));
            for(const t21 in s)s[t21] && !((r = this.et) === null || r === void 0 ? void 0 : r.has(t21)) && this.st.add(t21);
            return this.render(s);
        }
        const e2 = i2.element.classList;
        this.st.forEach((t2)=>{
            t2 in s || (e2.remove(t2), this.st.delete(t2));
        });
        for(const t22 in s){
            const i3 = !!s[t22];
            i3 === this.st.has(t22) || ((o2 = this.et) === null || o2 === void 0 ? void 0 : o2.has(t22)) || (i3 ? (e2.add(t22), this.st.add(t22)) : (e2.remove(t22), this.st.delete(t22)));
        }
        return _chunk2VBMOEKGJs.b;
    }
});

},{"./chunk.2JQPDYNA.js":"4Ri6Y","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Ri6Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "t", ()=>t
) /**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
parcelHelpers.export(exports, "e", ()=>e
);
parcelHelpers.export(exports, "i", ()=>i
);
// node_modules/lit-html/directive.js
var t = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
};
var e = (t2)=>(...e2)=>({
            _$litDirective$: t2,
            values: e2
        })
;
var i = class {
    constructor(t2){
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AT(t2, e2, i2) {
        this._$Ct = t2, this._$AM = e2, this._$Ci = i2;
    }
    _$AS(t2, e2) {
        return this.update(t2, e2);
    }
    update(t2, e2) {
        return this.render(...e2);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e6TXF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "l", ()=>l
) /**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// node_modules/lit-html/directives/if-defined.js
var l = (l2)=>l2 != null ? l2 : _chunk2VBMOEKGJs.w
;

},{"./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1j2NX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "watch", ()=>watch
);
// src/internal/watch.ts
function watch(propName, options) {
    return (protoOrDescriptor, name)=>{
        const { update  } = protoOrDescriptor;
        options = Object.assign({
            waitUntilFirstUpdate: false
        }, options);
        protoOrDescriptor.update = function(changedProps) {
            if (changedProps.has(propName)) {
                const oldValue = changedProps.get(propName);
                const newValue = this[propName];
                if (oldValue !== newValue) {
                    if (!(options == null ? void 0 : options.waitUntilFirstUpdate) || this.hasUpdated) this[name].call(this, oldValue, newValue);
                }
            }
            update.call(this, changedProps);
        };
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i4CGq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "emit", ()=>emit
);
parcelHelpers.export(exports, "waitForEvent", ()=>waitForEvent
);
// src/internal/event.ts
function emit(el, name, options) {
    const event = new CustomEvent(name, Object.assign({
        bubbles: true,
        cancelable: false,
        composed: true,
        detail: {
        }
    }, options));
    el.dispatchEvent(event);
    return event;
}
function waitForEvent(el, eventName) {
    return new Promise((resolve)=>{
        function done(event) {
            if (event.target === el) {
                el.removeEventListener(eventName, done);
                resolve();
            }
        }
        el.addEventListener(eventName, done);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a2lYY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "n", ()=>n
) /**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */  /**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
parcelHelpers.export(exports, "e", ()=>e
);
parcelHelpers.export(exports, "t", ()=>t
);
parcelHelpers.export(exports, "i", ()=>i2
);
parcelHelpers.export(exports, "e2", ()=>e2
);
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// node_modules/lit/node_modules/@lit/reactive-element/decorators/custom-element.js
var n = (n2)=>(e3)=>typeof e3 == "function" ? ((n3, e4)=>(window.customElements.define(n3, e4), e4)
        )(n2, e3) : ((n3, e4)=>{
            const { kind: t2 , elements: i3  } = e4;
            return {
                kind: t2,
                elements: i3,
                finisher (e5) {
                    window.customElements.define(n3, e5);
                }
            };
        })(n2, e3)
;
// node_modules/lit/node_modules/@lit/reactive-element/decorators/property.js
var i = (i3, e3)=>e3.kind === "method" && e3.descriptor && !("value" in e3.descriptor) ? _chunk4M3HOXYQJs.__spreadProps(_chunk4M3HOXYQJs.__spreadValues({
    }, e3), {
        finisher (n2) {
            n2.createProperty(e3.key, i3);
        }
    }) : {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {
        },
        originalKey: e3.key,
        initializer () {
            typeof e3.initializer == "function" && (this[e3.key] = e3.initializer.call(this));
        },
        finisher (n2) {
            n2.createProperty(e3.key, i3);
        }
    }
;
function e(e3) {
    return (n2, t2)=>t2 !== void 0 ? ((i3, e4, n3)=>{
            e4.constructor.createProperty(n3, i3);
        })(e3, n2, t2) : i(e3, n2)
    ;
}
// node_modules/lit/node_modules/@lit/reactive-element/decorators/state.js
function t(t2) {
    return e(_chunk4M3HOXYQJs.__spreadProps(_chunk4M3HOXYQJs.__spreadValues({
    }, t2), {
        state: true
    }));
}
// node_modules/lit/node_modules/@lit/reactive-element/decorators/base.js
var o = ({ finisher: e3 , descriptor: t2  })=>(o2, n2)=>{
        var r;
        if (n2 === void 0) {
            const n3 = (r = o2.originalKey) !== null && r !== void 0 ? r : o2.key, i3 = t2 != null ? {
                kind: "method",
                placement: "prototype",
                key: n3,
                descriptor: t2(o2.key)
            } : _chunk4M3HOXYQJs.__spreadProps(_chunk4M3HOXYQJs.__spreadValues({
            }, o2), {
                key: n3
            });
            return e3 != null && (i3.finisher = function(t3) {
                e3(t3, n3);
            }), i3;
        }
        {
            const r2 = o2.constructor;
            t2 !== void 0 && Object.defineProperty(o2, n2, t2(n2)), e3 == null || e3(r2, n2);
        }
    }
;
// node_modules/lit/node_modules/@lit/reactive-element/decorators/query.js
function i2(i3, n2) {
    return o({
        descriptor: (o2)=>{
            const t2 = {
                get () {
                    var o3, n3;
                    return (n3 = (o3 = this.renderRoot) === null || o3 === void 0 ? void 0 : o3.querySelector(i3)) !== null && n3 !== void 0 ? n3 : null;
                },
                enumerable: true,
                configurable: true
            };
            if (n2) {
                const n3 = typeof o2 == "symbol" ? Symbol() : "__" + o2;
                t2.get = function() {
                    var o3, t3;
                    return this[n3] === void 0 && (this[n3] = (t3 = (o3 = this.renderRoot) === null || o3 === void 0 ? void 0 : o3.querySelector(i3)) !== null && t3 !== void 0 ? t3 : null), this[n3];
                };
            }
            return t2;
        }
    });
}
// node_modules/lit/node_modules/@lit/reactive-element/decorators/query-async.js
function e2(e3) {
    return o({
        descriptor: (r)=>({
                async get () {
                    var r2;
                    return await this.updateComplete, (r2 = this.renderRoot) === null || r2 === void 0 ? void 0 : r2.querySelector(e3);
                },
                enumerable: true,
                configurable: true
            })
    });
}

},{"./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Tw6u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlIconButton", ()=>SlIconButton
);
var _chunkWCAFNYXWJs = require("./chunk.WCAFNYXW.js");
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkKJOCH52QJs = require("./chunk.KJOCH52Q.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/components/icon-button/icon-button.ts
var SlIconButton = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.label = "";
        this.disabled = false;
    }
    render() {
        const isLink = this.href ? true : false;
        const interior = _chunk2VBMOEKGJs.$`
      <sl-icon
        name=${_chunkKJOCH52QJs.l(this.name)}
        library=${_chunkKJOCH52QJs.l(this.library)}
        src=${_chunkKJOCH52QJs.l(this.src)}
        aria-hidden="true"
      ></sl-icon>
    `;
        return isLink ? _chunk2VBMOEKGJs.$`
          <a
            part="base"
            class="icon-button"
            href=${_chunkKJOCH52QJs.l(this.href)}
            target=${_chunkKJOCH52QJs.l(this.target)}
            download=${_chunkKJOCH52QJs.l(this.download)}
            rel=${_chunkKJOCH52QJs.l(this.target ? "noreferrer noopener" : void 0)}
            role="button"
            aria-disabled=${this.disabled ? "true" : "false"}
            aria-label="${this.label}"
            tabindex=${this.disabled ? "-1" : "0"}
          >
            ${interior}
          </a>
        ` : _chunk2VBMOEKGJs.$`
          <button
            part="base"
            class=${_chunkW2WMQSCEJs.o({
            "icon-button": true,
            "icon-button--disabled": this.disabled
        })}
            ?disabled=${this.disabled}
            type="button"
            aria-label=${this.label}
          >
            ${interior}
          </button>
        `;
    }
};
SlIconButton.styles = _chunkWCAFNYXWJs.icon_button_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i("button")
], SlIconButton.prototype, "button", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIconButton.prototype, "name", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIconButton.prototype, "library", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIconButton.prototype, "src", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIconButton.prototype, "href", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIconButton.prototype, "target", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIconButton.prototype, "download", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIconButton.prototype, "label", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlIconButton.prototype, "disabled", 2);
SlIconButton = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-icon-button")
], SlIconButton);

},{"./chunk.WCAFNYXW.js":"9Qo42","./chunk.W2WMQSCE.js":"9o2tn","./chunk.KJOCH52Q.js":"e6TXF","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Qo42":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "icon_button_styles_default", ()=>icon_button_styles_default
);
var _chunkAN2XMPAVJs = require("./chunk.AN2XMPAV.js");
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/icon-button/icon-button.styles.ts
var icon_button_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    display: inline-block;
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button${_chunkAN2XMPAVJs.focusVisibleSelector} {
    box-shadow: var(--sl-focus-ring);
  }
`;

},{"./chunk.AN2XMPAV.js":"2bW2A","./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2bW2A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasFocusVisible", ()=>hasFocusVisible
);
parcelHelpers.export(exports, "focusVisibleSelector", ()=>focusVisibleSelector
);
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/internal/focus-visible.ts
var hasFocusVisible = (()=>{
    const style = document.createElement("style");
    let isSupported;
    try {
        document.head.appendChild(style);
        style.sheet.insertRule(":focus-visible { color: inherit }");
        isSupported = true;
    } catch (e) {
        isSupported = false;
    } finally{
        style.remove();
    }
    return isSupported;
})();
var focusVisibleSelector = _chunk2VBMOEKGJs.o(hasFocusVisible ? ":focus-visible" : ":focus");

},{"./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bRaa7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "o", ()=>o
) /**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
parcelHelpers.export(exports, "SlIcon", ()=>SlIcon
);
var _chunkL4IDTG64Js = require("./chunk.L4IDTG64.js");
var _chunkUJSH3WGMJs = require("./chunk.UJSH3WGM.js");
var _chunk4KUWHA33Js = require("./chunk.4KUWHA33.js");
var _chunkKJOCH52QJs = require("./chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("./chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("./chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("./chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// node_modules/lit-html/directives/unsafe-html.js
var e3 = class extends _chunk2JQPDYNAJs.i {
    constructor(i2){
        if (super(i2), this.it = _chunk2VBMOEKGJs.w, i2.type !== _chunk2JQPDYNAJs.t.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
    }
    render(r) {
        if (r === _chunk2VBMOEKGJs.w || r == null) return this.vt = void 0, this.it = r;
        if (r === _chunk2VBMOEKGJs.b) return r;
        if (typeof r != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
        if (r === this.it) return this.vt;
        this.it = r;
        const s2 = [
            r
        ];
        return s2.raw = s2, this.vt = {
            _$litType$: this.constructor.resultType,
            strings: s2,
            values: []
        };
    }
};
e3.directiveName = "unsafeHTML", e3.resultType = 1;
var o = _chunk2JQPDYNAJs.e(e3);
// node_modules/lit-html/directives/unsafe-svg.js
var t3 = class extends e3 {
};
t3.directiveName = "unsafeSVG", t3.resultType = 2;
var o2 = _chunk2JQPDYNAJs.e(t3);
// src/components/icon/icon.ts
var parser = new DOMParser();
var SlIcon = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.svg = "";
        this.library = "default";
    }
    connectedCallback() {
        super.connectedCallback();
        _chunkL4IDTG64Js.watchIcon(this);
    }
    firstUpdated() {
        this.setIcon();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        _chunkL4IDTG64Js.unwatchIcon(this);
    }
    getUrl() {
        const library = _chunkL4IDTG64Js.getIconLibrary(this.library);
        if (this.name && library) return library.resolver(this.name);
        else return this.src;
    }
    redraw() {
        this.setIcon();
    }
    async setIcon() {
        const library = _chunkL4IDTG64Js.getIconLibrary(this.library);
        const url = this.getUrl();
        if (url) try {
            const file = await _chunkUJSH3WGMJs.requestIcon(url);
            if (url !== this.getUrl()) return;
            else if (file.ok) {
                const doc = parser.parseFromString(file.svg, "text/html");
                const svgEl = doc.body.querySelector("svg");
                if (svgEl) {
                    if (library && library.mutator) library.mutator(svgEl);
                    this.svg = svgEl.outerHTML;
                    _chunkI4TE3TJVJs.emit(this, "sl-load");
                } else {
                    this.svg = "";
                    _chunkI4TE3TJVJs.emit(this, "sl-error", {
                        detail: {
                            status: file.status
                        }
                    });
                }
            } else {
                this.svg = "";
                _chunkI4TE3TJVJs.emit(this, "sl-error", {
                    detail: {
                        status: file.status
                    }
                });
            }
        } catch (e4) {
            _chunkI4TE3TJVJs.emit(this, "sl-error", {
                detail: {
                    status: -1
                }
            });
        }
        else if (this.svg) this.svg = "";
    }
    handleChange() {
        this.setIcon();
    }
    render() {
        const hasLabel = typeof this.label === "string" && this.label.length > 0;
        return _chunk2VBMOEKGJs.$` <div
      part="base"
      class="icon"
      role=${_chunkKJOCH52QJs.l(hasLabel ? "img" : void 0)}
      aria-label=${_chunkKJOCH52QJs.l(hasLabel ? this.label : void 0)}
      aria-hidden=${_chunkKJOCH52QJs.l(hasLabel ? void 0 : "true")}
    >
      ${o2(this.svg)}
    </div>`;
    }
};
SlIcon.styles = _chunk4KUWHA33Js.icon_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.t()
], SlIcon.prototype, "svg", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIcon.prototype, "name", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIcon.prototype, "src", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIcon.prototype, "label", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlIcon.prototype, "library", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("name"),
    _chunkBD26TKS4Js.watch("src"),
    _chunkBD26TKS4Js.watch("library")
], SlIcon.prototype, "setIcon", 1);
SlIcon = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-icon")
], SlIcon);

},{"./chunk.L4IDTG64.js":"5bB1j","./chunk.UJSH3WGM.js":"7vHmo","./chunk.4KUWHA33.js":"69rgo","./chunk.KJOCH52Q.js":"e6TXF","./chunk.2JQPDYNA.js":"4Ri6Y","./chunk.BD26TKS4.js":"1j2NX","./chunk.I4TE3TJV.js":"i4CGq","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5bB1j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "watchIcon", ()=>watchIcon
);
parcelHelpers.export(exports, "unwatchIcon", ()=>unwatchIcon
);
parcelHelpers.export(exports, "getIconLibrary", ()=>getIconLibrary
);
parcelHelpers.export(exports, "registerIconLibrary", ()=>registerIconLibrary
);
parcelHelpers.export(exports, "unregisterIconLibrary", ()=>unregisterIconLibrary
);
var _chunkC7PPQWMAJs = require("./chunk.C7PPQWMA.js");
var _chunkHEOUBJ7TJs = require("./chunk.HEOUBJ7T.js");
// src/components/icon/library.ts
var registry = [
    _chunkC7PPQWMAJs.library_default_default,
    _chunkHEOUBJ7TJs.library_system_default
];
var watchedIcons = [];
function watchIcon(icon) {
    watchedIcons.push(icon);
}
function unwatchIcon(icon) {
    watchedIcons = watchedIcons.filter((el)=>el !== icon
    );
}
function getIconLibrary(name) {
    return registry.filter((lib)=>lib.name === name
    )[0];
}
function registerIconLibrary(name, options) {
    unregisterIconLibrary(name);
    registry.push({
        name,
        resolver: options.resolver,
        mutator: options.mutator
    });
    watchedIcons.map((icon)=>{
        if (icon.library === name) icon.redraw();
    });
}
function unregisterIconLibrary(name) {
    registry = registry.filter((lib)=>lib.name !== name
    );
}

},{"./chunk.C7PPQWMA.js":"szhSB","./chunk.HEOUBJ7T.js":"3YVet","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"szhSB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "library_default_default", ()=>library_default_default
);
var _chunkNFF2HMITJs = require("./chunk.NFF2HMIT.js");
// src/components/icon/library.default.ts
var library = {
    name: "default",
    resolver: (name)=>`${_chunkNFF2HMITJs.getBasePath()}/assets/icons/${name}.svg`
};
var library_default_default = library;

},{"./chunk.NFF2HMIT.js":"fX0do","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fX0do":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setBasePath", ()=>setBasePath
);
parcelHelpers.export(exports, "getBasePath", ()=>getBasePath
);
// src/utilities/base-path.ts
var basePath = "";
function setBasePath(path) {
    basePath = path;
}
function getBasePath() {
    return basePath.replace(/\/$/, "");
}
var scripts = [
    ...document.getElementsByTagName("script")
];
var configScript = scripts.find((script)=>script.hasAttribute("data-shoelace")
);
if (configScript) setBasePath(configScript.getAttribute("data-shoelace"));
else {
    const fallbackScript = scripts.find((s)=>/shoelace(\.min)?\.js($|\?)/.test(s.src)
    );
    let path = "";
    if (fallbackScript) path = fallbackScript.getAttribute("src");
    setBasePath(path.split("/").slice(0, -1).join("/"));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3YVet":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "library_system_default", ()=>library_system_default
);
// src/components/icon/library.system.ts
var icons = {
    check: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
      <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/>
    </svg>
  `,
    "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
    "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
    "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
    eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
    "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
    eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
    "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
    </svg>
  `,
    "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
    "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
    "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
    "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
    x: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
      <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
    "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
    name: "system",
    resolver: (name)=>{
        if (icons[name]) return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
        else return "";
    }
};
var library_system_default = systemLibrary;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7vHmo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "requestIcon", ()=>requestIcon
);
// src/components/icon/request.ts
var iconFiles = /* @__PURE__ */ new Map();
var requestIcon = (url)=>{
    if (iconFiles.has(url)) return iconFiles.get(url);
    else {
        const request = fetch(url).then(async (response)=>{
            if (response.ok) {
                const div = document.createElement("div");
                div.innerHTML = await response.text();
                const svg = div.firstElementChild;
                return {
                    ok: response.ok,
                    status: response.status,
                    svg: svg && svg.tagName.toLowerCase() === "svg" ? svg.outerHTML : ""
                };
            } else return {
                ok: response.ok,
                status: response.status,
                svg: null
            };
        });
        iconFiles.set(url, request);
        return request;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"69rgo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "icon_styles_default", ()=>icon_styles_default
);
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/icon/icon.styles.ts
var icon_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    contain: strict;
    box-sizing: content-box !important;
  }

  .icon,
  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

},{"./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9AbKL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunk5IWLS7YMJs.SlButton
);
var _chunk5IWLS7YMJs = require("../../chunks/chunk.5IWLS7YM.js");
var _chunkZNDHS74KJs = require("../../chunks/chunk.ZNDHS74K.js");
var _chunk2G6AZSJBJs = require("../../chunks/chunk.2G6AZSJB.js");
var _chunkNTBOGFL4Js = require("../../chunks/chunk.NTBOGFL4.js");
var _chunk4654KI5LJs = require("../../chunks/chunk.4654KI5L.js");
var _chunk5TL5QPK4Js = require("../../chunks/chunk.5TL5QPK4.js");
var _chunkW2WMQSCEJs = require("../../chunks/chunk.W2WMQSCE.js");
var _chunkAN2XMPAVJs = require("../../chunks/chunk.AN2XMPAV.js");
var _chunkKJOCH52QJs = require("../../chunks/chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.5IWLS7YM.js":"98Wo8","../../chunks/chunk.ZNDHS74K.js":"9L9Hz","../../chunks/chunk.2G6AZSJB.js":"7xhPc","../../chunks/chunk.NTBOGFL4.js":"45eD3","../../chunks/chunk.4654KI5L.js":"3AQaY","../../chunks/chunk.5TL5QPK4.js":"akO45","../../chunks/chunk.W2WMQSCE.js":"9o2tn","../../chunks/chunk.AN2XMPAV.js":"2bW2A","../../chunks/chunk.KJOCH52Q.js":"e6TXF","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"98Wo8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlButton", ()=>SlButton
) /**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
var _chunkNTBOGFL4Js = require("./chunk.NTBOGFL4.js");
var _chunk4654KI5LJs = require("./chunk.4654KI5L.js");
var _chunk5TL5QPK4Js = require("./chunk.5TL5QPK4.js");
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkKJOCH52QJs = require("./chunk.KJOCH52Q.js");
var _chunkI4TE3TJVJs = require("./chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// node_modules/lit-html/static.js
var r = (t2, ...e2)=>({
        _$litStatic$: e2.reduce((e3, o2, r2)=>e3 + ((t3)=>{
                if (t3._$litStatic$ !== void 0) return t3._$litStatic$;
                throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t3}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
            })(o2) + t2[r2 + 1]
        , t2[0])
    })
;
var i2 = /* @__PURE__ */ new Map();
var a = (t2)=>(e2, ...o2)=>{
        var r2;
        const a2 = o2.length;
        let l3, s3;
        const n2 = [], u = [];
        let c, $2 = 0, v = false;
        for(; $2 < a2;){
            for(c = e2[$2]; $2 < a2 && (s3 = o2[$2], l3 = (r2 = s3) === null || r2 === void 0 ? void 0 : r2._$litStatic$) !== void 0;)c += l3 + e2[++$2], v = true;
            u.push(s3), n2.push(c), $2++;
        }
        if ($2 === a2 && n2.push(e2[a2]), v) {
            const t3 = n2.join("$$lit$$");
            (e2 = i2.get(t3)) === void 0 && (n2.raw = n2, i2.set(t3, e2 = n2)), o2 = u;
        }
        return t2(e2, ...o2);
    }
;
var l2 = a(_chunk2VBMOEKGJs.$);
var s2 = a(_chunk2VBMOEKGJs.y);
// src/components/button/button.ts
var SlButton = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.formSubmitController = new _chunk4654KI5LJs.FormSubmitController(this);
        this.hasSlotController = new _chunk5TL5QPK4Js.HasSlotController(this, "[default]", "prefix", "suffix");
        this.hasFocus = false;
        this.variant = "default";
        this.size = "medium";
        this.caret = false;
        this.disabled = false;
        this.loading = false;
        this.outline = false;
        this.pill = false;
        this.circle = false;
        this.type = "button";
    }
    click() {
        this.button.click();
    }
    focus(options) {
        this.button.focus(options);
    }
    blur() {
        this.button.blur();
    }
    handleBlur() {
        this.hasFocus = false;
        _chunkI4TE3TJVJs.emit(this, "sl-blur");
    }
    handleFocus() {
        this.hasFocus = true;
        _chunkI4TE3TJVJs.emit(this, "sl-focus");
    }
    handleClick(event) {
        if (this.disabled || this.loading) {
            event.preventDefault();
            event.stopPropagation();
            return;
        }
        if (this.type === "submit") this.formSubmitController.submit();
    }
    render() {
        const isLink = this.href ? true : false;
        const tag = isLink ? r`a` : r`button`;
        return l2`
      <${tag}
        part="base"
        class=${_chunkW2WMQSCEJs.o({
            button: true,
            "button--default": this.variant === "default",
            "button--primary": this.variant === "primary",
            "button--success": this.variant === "success",
            "button--neutral": this.variant === "neutral",
            "button--warning": this.variant === "warning",
            "button--danger": this.variant === "danger",
            "button--text": this.variant === "text",
            "button--small": this.size === "small",
            "button--medium": this.size === "medium",
            "button--large": this.size === "large",
            "button--caret": this.caret,
            "button--circle": this.circle,
            "button--disabled": this.disabled,
            "button--focused": this.hasFocus,
            "button--loading": this.loading,
            "button--standard": !this.outline,
            "button--outline": this.outline,
            "button--pill": this.pill,
            "button--has-label": this.hasSlotController.test("[default]"),
            "button--has-prefix": this.hasSlotController.test("prefix"),
            "button--has-suffix": this.hasSlotController.test("suffix")
        })}
        ?disabled=${_chunkKJOCH52QJs.l(isLink ? void 0 : this.disabled)}
        type=${this.type}
        name=${_chunkKJOCH52QJs.l(isLink ? void 0 : this.name)}
        value=${_chunkKJOCH52QJs.l(isLink ? void 0 : this.value)}
        href=${_chunkKJOCH52QJs.l(this.href)}
        target=${_chunkKJOCH52QJs.l(this.target)}
        download=${_chunkKJOCH52QJs.l(this.download)}
        rel=${_chunkKJOCH52QJs.l(this.target ? "noreferrer noopener" : void 0)}
        role="button"
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <span part="prefix" class="button__prefix">
          <slot name="prefix"></slot>
        </span>
        <span part="label" class="button__label">
          <slot></slot>
        </span>
        <span part="suffix" class="button__suffix">
          <slot name="suffix"></slot>
        </span>
        ${this.caret ? l2`
                <span part="caret" class="button__caret">
                  <svg
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </span>
              ` : ""}
        ${this.loading ? l2`<sl-spinner></sl-spinner>` : ""}
      </${tag}>
    `;
    }
};
SlButton.styles = _chunkNTBOGFL4Js.button_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".button")
], SlButton.prototype, "button", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.t()
], SlButton.prototype, "hasFocus", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        reflect: true
    })
], SlButton.prototype, "variant", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        reflect: true
    })
], SlButton.prototype, "size", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlButton.prototype, "caret", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlButton.prototype, "disabled", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlButton.prototype, "loading", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlButton.prototype, "outline", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlButton.prototype, "pill", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlButton.prototype, "circle", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlButton.prototype, "type", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlButton.prototype, "name", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlButton.prototype, "value", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlButton.prototype, "href", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlButton.prototype, "target", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlButton.prototype, "download", 2);
SlButton = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-button")
], SlButton);

},{"./chunk.NTBOGFL4.js":"45eD3","./chunk.4654KI5L.js":"3AQaY","./chunk.5TL5QPK4.js":"akO45","./chunk.W2WMQSCE.js":"9o2tn","./chunk.KJOCH52Q.js":"e6TXF","./chunk.I4TE3TJV.js":"i4CGq","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"45eD3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "button_styles_default", ()=>button_styles_default
);
var _chunkAN2XMPAVJs = require("./chunk.AN2XMPAV.js");
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/button/button.styles.ts
var button_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition: var(--sl-transition-fast) background-color, var(--sl-transition-fast) color,
      var(--sl-transition-fast) border, var(--sl-transition-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label ::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
    box-shadow: var(--sl-focus-ring);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-success-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-neutral-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-warning-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    border-color: var(--sl-color-danger-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
    box-shadow: var(--sl-focus-ring);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    font-size: var(--sl-button-font-size-small);
    height: var(--sl-input-height-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    font-size: var(--sl-button-font-size-medium);
    height: var(--sl-input-height-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    font-size: var(--sl-button-font-size-large);
    height: var(--sl-input-height-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    display: flex;
    align-items: center;
  }

  .button--caret .button__caret svg {
    width: 1em;
    height: 1em;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    transform: translateY(-50%) translateX(50%);
    pointer-events: none;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-left: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-left: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-left: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-right: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-right: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-right: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-right: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-left: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(.sl-button-group__button:not(.sl-button-group__button--focus, .sl-button-group__button--first, [variant='default']):not(:hover, :active, :focus))
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump focused buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  :host(.sl-button-group__button--focus) {
    z-index: 2;
  }
`;

},{"./chunk.AN2XMPAV.js":"2bW2A","./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3AQaY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FormSubmitController", ()=>FormSubmitController
);
parcelHelpers.export(exports, "renderFormControl", ()=>renderFormControl
);
parcelHelpers.export(exports, "getLabelledBy", ()=>getLabelledBy
);
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkKJOCH52QJs = require("./chunk.KJOCH52Q.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/internal/formdata-event-polyfill.ts
var FormDataEventPolyfill = class extends Event {
    constructor(formData){
        super("formdata");
        this.formData = formData;
    }
};
var FormDataPolyfill = class extends FormData {
    constructor(form){
        super(form);
        this.form = form;
        form.dispatchEvent(new FormDataEventPolyfill(this));
    }
    append(name, value) {
        let input = this.form.elements[name];
        if (!input) {
            input = document.createElement("input");
            input.type = "hidden";
            input.name = name;
            this.form.appendChild(input);
        }
        if (this.has(name)) {
            const entries = this.getAll(name);
            const index = entries.indexOf(input.value);
            if (index !== -1) entries.splice(index, 1);
            entries.push(value);
            this.set(name, entries);
        } else super.append(name, value);
        input.value = value;
    }
};
function supportsFormDataEvent() {
    const form = document.createElement("form");
    let isSupported = false;
    document.body.append(form);
    form.addEventListener("submit", (event)=>{
        new FormData(event.target);
        event.preventDefault();
    });
    form.addEventListener("formdata", ()=>isSupported = true
    );
    form.dispatchEvent(new Event("submit", {
        cancelable: true
    }));
    form.remove();
    return isSupported;
}
function polyfillFormData() {
    if (!window.FormData || supportsFormDataEvent()) return;
    window.FormData = FormDataPolyfill;
    window.addEventListener("submit", (event)=>{
        if (!event.defaultPrevented) new FormData(event.target);
    });
}
polyfillFormData();
// src/internal/form-control.ts
var FormSubmitController = class {
    constructor(host, options){
        (this.host = host).addController(this);
        this.options = Object.assign({
            form: (input)=>input.closest("form")
            ,
            name: (input)=>input.name
            ,
            value: (input)=>input.value
            ,
            disabled: (input)=>input.disabled
            ,
            reportValidity: (input)=>{
                return typeof input.reportValidity === "function" ? input.reportValidity() : true;
            }
        }, options);
        this.handleFormData = this.handleFormData.bind(this);
        this.handleFormSubmit = this.handleFormSubmit.bind(this);
    }
    hostConnected() {
        var _a;
        this.form = (_a = this.options) == null ? void 0 : _a.form(this.host);
        if (this.form) {
            this.form.addEventListener("formdata", this.handleFormData);
            this.form.addEventListener("submit", this.handleFormSubmit);
        }
    }
    hostDisconnected() {
        if (this.form) {
            this.form.removeEventListener("formdata", this.handleFormData);
            this.form.removeEventListener("submit", this.handleFormSubmit);
            this.form = void 0;
        }
    }
    handleFormData(event) {
        var _a, _b, _c;
        const disabled = (_a = this.options) == null ? void 0 : _a.disabled(this.host);
        const name = (_b = this.options) == null ? void 0 : _b.name(this.host);
        const value = (_c = this.options) == null ? void 0 : _c.value(this.host);
        if (!disabled && name && value !== void 0) {
            if (Array.isArray(value)) value.map((val)=>event.formData.append(name, val)
            );
            else event.formData.append(name, value);
        }
    }
    handleFormSubmit(event) {
        var _a, _b;
        const form = this.form;
        const disabled = (_a = this.options) == null ? void 0 : _a.disabled(this.host);
        const reportValidity = (_b = this.options) == null ? void 0 : _b.reportValidity;
        if (form && !form.noValidate && !disabled && reportValidity && !reportValidity(this.host)) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }
    submit() {
        const button = document.createElement("button");
        if (this.form) {
            button.type = "submit";
            button.style.position = "absolute";
            button.style.width = "0";
            button.style.height = "0";
            button.style.clip = "rect(0 0 0 0)";
            button.style.clipPath = "inset(50%)";
            button.style.overflow = "hidden";
            button.style.whiteSpace = "nowrap";
            this.form.append(button);
            button.click();
            button.remove();
        }
    }
};
var renderFormControl = (props, input)=>{
    const hasLabel = props.label ? true : !!props.hasLabelSlot;
    const hasHelpText = props.helpText ? true : !!props.hasHelpTextSlot;
    return _chunk2VBMOEKGJs.$`
    <div
      part="form-control"
      class=${_chunkW2WMQSCEJs.o({
        "form-control": true,
        "form-control--small": props.size === "small",
        "form-control--medium": props.size === "medium",
        "form-control--large": props.size === "large",
        "form-control--has-label": hasLabel,
        "form-control--has-help-text": hasHelpText
    })}
    >
      <label
        part="label"
        id=${_chunkKJOCH52QJs.l(props.labelId)}
        class="form-control__label"
        for=${props.inputId}
        aria-hidden=${hasLabel ? "false" : "true"}
        @click=${(event)=>props.onLabelClick ? props.onLabelClick(event) : null
    }
      >
        <slot name="label">${props.label}</slot>
      </label>

      <div class="form-control__input">${_chunk2VBMOEKGJs.$`${input}`}</div>

      <div
        part="help-text"
        id=${_chunkKJOCH52QJs.l(props.helpTextId)}
        class="form-control__help-text"
        aria-hidden=${hasHelpText ? "false" : "true"}
      >
        <slot name="help-text">${props.helpText}</slot>
      </div>
    </div>
  `;
};
function getLabelledBy(props) {
    const labelledBy = [
        props.label || props.hasLabelSlot ? props.labelId : "",
        props.helpText || props.hasHelpTextSlot ? props.helpTextId : ""
    ].filter((val)=>val
    );
    return labelledBy.join(" ") || void 0;
}

},{"./chunk.W2WMQSCE.js":"9o2tn","./chunk.KJOCH52Q.js":"e6TXF","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9L9Hz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlSpinner", ()=>SlSpinner
);
var _chunk2G6AZSJBJs = require("./chunk.2G6AZSJB.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/components/spinner/spinner.ts
var SlSpinner = class extends _chunk2VBMOEKGJs.s {
    render() {
        return _chunk2VBMOEKGJs.$`
      <svg part="base" class="spinner" role="status">
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
    }
};
SlSpinner.styles = _chunk2G6AZSJBJs.spinner_styles_default;
SlSpinner = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-spinner")
], SlSpinner);

},{"./chunk.2G6AZSJB.js":"7xhPc","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7xhPc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "spinner_styles_default", ()=>spinner_styles_default
);
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/spinner/spinner.styles.ts
var spinner_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 800ms;

    display: inline-flex;
    width: 1em;
    height: 1em;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
    mix-blend-mode: multiply;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
`;

},{"./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ii4L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunkQSLHMB3EJs.SlIconButton
);
var _chunkQSLHMB3EJs = require("../../chunks/chunk.QSLHMB3E.js");
var _chunkWCAFNYXWJs = require("../../chunks/chunk.WCAFNYXW.js");
var _chunkW2WMQSCEJs = require("../../chunks/chunk.W2WMQSCE.js");
var _chunkAN2XMPAVJs = require("../../chunks/chunk.AN2XMPAV.js");
var _chunkIBSPWXHKJs = require("../../chunks/chunk.IBSPWXHK.js");
var _chunkL4IDTG64Js = require("../../chunks/chunk.L4IDTG64.js");
var _chunkC7PPQWMAJs = require("../../chunks/chunk.C7PPQWMA.js");
var _chunkNFF2HMITJs = require("../../chunks/chunk.NFF2HMIT.js");
var _chunkHEOUBJ7TJs = require("../../chunks/chunk.HEOUBJ7T.js");
var _chunkUJSH3WGMJs = require("../../chunks/chunk.UJSH3WGM.js");
var _chunk4KUWHA33Js = require("../../chunks/chunk.4KUWHA33.js");
var _chunkKJOCH52QJs = require("../../chunks/chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("../../chunks/chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.QSLHMB3E.js":"2Tw6u","../../chunks/chunk.WCAFNYXW.js":"9Qo42","../../chunks/chunk.W2WMQSCE.js":"9o2tn","../../chunks/chunk.AN2XMPAV.js":"2bW2A","../../chunks/chunk.IBSPWXHK.js":"bRaa7","../../chunks/chunk.L4IDTG64.js":"5bB1j","../../chunks/chunk.C7PPQWMA.js":"szhSB","../../chunks/chunk.NFF2HMIT.js":"fX0do","../../chunks/chunk.HEOUBJ7T.js":"3YVet","../../chunks/chunk.UJSH3WGM.js":"7vHmo","../../chunks/chunk.4KUWHA33.js":"69rgo","../../chunks/chunk.KJOCH52Q.js":"e6TXF","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.BD26TKS4.js":"1j2NX","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1eEuu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunk5PGDTRSWJs.SlDrawer
);
var _chunk5PGDTRSWJs = require("../../chunks/chunk.5PGDTRSW.js");
var _chunkZXQWYC2KJs = require("../../chunks/chunk.ZXQWYC2K.js");
var _chunkSXNB3LL3Js = require("../../chunks/chunk.SXNB3LL3.js");
var _chunkDTSUHNT6Js = require("../../chunks/chunk.DTSUHNT6.js");
var _chunkST4GEPNZJs = require("../../chunks/chunk.ST4GEPNZ.js");
var _chunk5TL5QPK4Js = require("../../chunks/chunk.5TL5QPK4.js");
var _chunkQSLHMB3EJs = require("../../chunks/chunk.QSLHMB3E.js");
var _chunkWCAFNYXWJs = require("../../chunks/chunk.WCAFNYXW.js");
var _chunk6JY65IM5Js = require("../../chunks/chunk.6JY65IM5.js");
var _chunkUTEQRIIYJs = require("../../chunks/chunk.UTEQRIIY.js");
var _chunkW2WMQSCEJs = require("../../chunks/chunk.W2WMQSCE.js");
var _chunkAN2XMPAVJs = require("../../chunks/chunk.AN2XMPAV.js");
var _chunkIBSPWXHKJs = require("../../chunks/chunk.IBSPWXHK.js");
var _chunkL4IDTG64Js = require("../../chunks/chunk.L4IDTG64.js");
var _chunkC7PPQWMAJs = require("../../chunks/chunk.C7PPQWMA.js");
var _chunkNFF2HMITJs = require("../../chunks/chunk.NFF2HMIT.js");
var _chunkHEOUBJ7TJs = require("../../chunks/chunk.HEOUBJ7T.js");
var _chunkUJSH3WGMJs = require("../../chunks/chunk.UJSH3WGM.js");
var _chunk4KUWHA33Js = require("../../chunks/chunk.4KUWHA33.js");
var _chunkKJOCH52QJs = require("../../chunks/chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("../../chunks/chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.5PGDTRSW.js":"i9chM","../../chunks/chunk.ZXQWYC2K.js":"luWMM","../../chunks/chunk.SXNB3LL3.js":"cN7v8","../../chunks/chunk.DTSUHNT6.js":"a7RTw","../../chunks/chunk.ST4GEPNZ.js":"ao9ex","../../chunks/chunk.5TL5QPK4.js":"akO45","../../chunks/chunk.QSLHMB3E.js":"2Tw6u","../../chunks/chunk.WCAFNYXW.js":"9Qo42","../../chunks/chunk.6JY65IM5.js":"d40Fl","../../chunks/chunk.UTEQRIIY.js":"h4h4P","../../chunks/chunk.W2WMQSCE.js":"9o2tn","../../chunks/chunk.AN2XMPAV.js":"2bW2A","../../chunks/chunk.IBSPWXHK.js":"bRaa7","../../chunks/chunk.L4IDTG64.js":"5bB1j","../../chunks/chunk.C7PPQWMA.js":"szhSB","../../chunks/chunk.NFF2HMIT.js":"fX0do","../../chunks/chunk.HEOUBJ7T.js":"3YVet","../../chunks/chunk.UJSH3WGM.js":"7vHmo","../../chunks/chunk.4KUWHA33.js":"69rgo","../../chunks/chunk.KJOCH52Q.js":"e6TXF","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.BD26TKS4.js":"1j2NX","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i9chM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlDrawer", ()=>SlDrawer
);
var _chunkZXQWYC2KJs = require("./chunk.ZXQWYC2K.js");
var _chunkSXNB3LL3Js = require("./chunk.SXNB3LL3.js");
var _chunkST4GEPNZJs = require("./chunk.ST4GEPNZ.js");
var _chunk5TL5QPK4Js = require("./chunk.5TL5QPK4.js");
var _chunk6JY65IM5Js = require("./chunk.6JY65IM5.js");
var _chunkUTEQRIIYJs = require("./chunk.UTEQRIIY.js");
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkKJOCH52QJs = require("./chunk.KJOCH52Q.js");
var _chunkBD26TKS4Js = require("./chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("./chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/internal/string.ts
function uppercaseFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
// src/components/drawer/drawer.ts
var hasPreventScroll = _chunkSXNB3LL3Js.isPreventScrollSupported();
var SlDrawer = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.hasSlotController = new _chunk5TL5QPK4Js.HasSlotController(this, "footer");
        this.open = false;
        this.label = "";
        this.placement = "end";
        this.contained = false;
        this.noHeader = false;
    }
    connectedCallback() {
        super.connectedCallback();
        this.modal = new _chunkSXNB3LL3Js.Modal(this);
    }
    firstUpdated() {
        this.drawer.hidden = !this.open;
        if (this.open && !this.contained) {
            this.modal.activate();
            _chunkST4GEPNZJs.lockBodyScrolling(this);
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        _chunkST4GEPNZJs.unlockBodyScrolling(this);
    }
    async show() {
        if (this.open) return;
        this.open = true;
        return _chunkI4TE3TJVJs.waitForEvent(this, "sl-after-show");
    }
    async hide() {
        if (!this.open) return;
        this.open = false;
        return _chunkI4TE3TJVJs.waitForEvent(this, "sl-after-hide");
    }
    requestClose() {
        const slRequestClose = _chunkI4TE3TJVJs.emit(this, "sl-request-close", {
            cancelable: true
        });
        if (slRequestClose.defaultPrevented) {
            const animation = _chunkUTEQRIIYJs.getAnimation(this, "drawer.denyClose");
            _chunk6JY65IM5Js.animateTo(this.panel, animation.keyframes, animation.options);
            return;
        }
        this.hide();
    }
    handleKeyDown(event) {
        if (event.key === "Escape") {
            event.stopPropagation();
            this.requestClose();
        }
    }
    async handleOpenChange() {
        if (this.open) {
            _chunkI4TE3TJVJs.emit(this, "sl-show");
            this.originalTrigger = document.activeElement;
            if (!this.contained) {
                this.modal.activate();
                _chunkST4GEPNZJs.lockBodyScrolling(this);
            }
            await Promise.all([
                _chunk6JY65IM5Js.stopAnimations(this.drawer),
                _chunk6JY65IM5Js.stopAnimations(this.overlay)
            ]);
            this.drawer.hidden = false;
            if (hasPreventScroll) {
                const slInitialFocus = _chunkI4TE3TJVJs.emit(this, "sl-initial-focus", {
                    cancelable: true
                });
                if (!slInitialFocus.defaultPrevented) this.panel.focus({
                    preventScroll: true
                });
            }
            const panelAnimation = _chunkUTEQRIIYJs.getAnimation(this, `drawer.show${uppercaseFirstLetter(this.placement)}`);
            const overlayAnimation = _chunkUTEQRIIYJs.getAnimation(this, "drawer.overlay.show");
            await Promise.all([
                _chunk6JY65IM5Js.animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
                _chunk6JY65IM5Js.animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
            ]);
            if (!hasPreventScroll) {
                const slInitialFocus = _chunkI4TE3TJVJs.emit(this, "sl-initial-focus", {
                    cancelable: true
                });
                if (!slInitialFocus.defaultPrevented) this.panel.focus({
                    preventScroll: true
                });
            }
            _chunkI4TE3TJVJs.emit(this, "sl-after-show");
        } else {
            _chunkI4TE3TJVJs.emit(this, "sl-hide");
            this.modal.deactivate();
            _chunkST4GEPNZJs.unlockBodyScrolling(this);
            await Promise.all([
                _chunk6JY65IM5Js.stopAnimations(this.drawer),
                _chunk6JY65IM5Js.stopAnimations(this.overlay)
            ]);
            const panelAnimation = _chunkUTEQRIIYJs.getAnimation(this, `drawer.hide${uppercaseFirstLetter(this.placement)}`);
            const overlayAnimation = _chunkUTEQRIIYJs.getAnimation(this, "drawer.overlay.hide");
            await Promise.all([
                _chunk6JY65IM5Js.animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
                _chunk6JY65IM5Js.animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)
            ]);
            this.drawer.hidden = true;
            const trigger = this.originalTrigger;
            if (trigger && typeof trigger.focus === "function") setTimeout(()=>trigger.focus()
            );
            _chunkI4TE3TJVJs.emit(this, "sl-after-hide");
        }
    }
    render() {
        return _chunk2VBMOEKGJs.$`
      <div
        part="base"
        class=${_chunkW2WMQSCEJs.o({
            drawer: true,
            "drawer--open": this.open,
            "drawer--top": this.placement === "top",
            "drawer--end": this.placement === "end",
            "drawer--bottom": this.placement === "bottom",
            "drawer--start": this.placement === "start",
            "drawer--contained": this.contained,
            "drawer--fixed": !this.contained,
            "drawer--has-footer": this.hasSlotController.test("footer")
        })}
        @keydown=${this.handleKeyDown}
      >
        <div part="overlay" class="drawer__overlay" @click=${this.requestClose} tabindex="-1"></div>

        <div
          part="panel"
          class="drawer__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${_chunkKJOCH52QJs.l(this.noHeader ? this.label : void 0)}
          aria-labelledby=${_chunkKJOCH52QJs.l(!this.noHeader ? "title" : void 0)}
          tabindex="0"
        >
          ${!this.noHeader ? _chunk2VBMOEKGJs.$`
                <header part="header" class="drawer__header">
                  <span part="title" class="drawer__title" id="title">
                    <\!-- If there's no label, use an invisible character to prevent the header from collapsing -->
                    <slot name="label"> ${this.label || String.fromCharCode(65279)} </slot>
                  </span>
                  <sl-icon-button
                    exportparts="base:close-button"
                    class="drawer__close"
                    name="x"
                    library="system"
                    @click=${this.requestClose}
                  ></sl-icon-button>
                </header>
              ` : ""}

          <div part="body" class="drawer__body">
            <slot></slot>
          </div>

          <footer part="footer" class="drawer__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
    }
};
SlDrawer.styles = _chunkZXQWYC2KJs.drawer_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".drawer")
], SlDrawer.prototype, "drawer", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".drawer__panel")
], SlDrawer.prototype, "panel", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".drawer__overlay")
], SlDrawer.prototype, "overlay", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlDrawer.prototype, "open", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        reflect: true
    })
], SlDrawer.prototype, "label", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        reflect: true
    })
], SlDrawer.prototype, "placement", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlDrawer.prototype, "contained", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        attribute: "no-header",
        type: Boolean,
        reflect: true
    })
], SlDrawer.prototype, "noHeader", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("open", {
        waitUntilFirstUpdate: true
    })
], SlDrawer.prototype, "handleOpenChange", 1);
SlDrawer = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-drawer")
], SlDrawer);
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.showTop", {
    keyframes: [
        {
            opacity: 0,
            transform: "translateY(-100%)"
        },
        {
            opacity: 1,
            transform: "translateY(0)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.hideTop", {
    keyframes: [
        {
            opacity: 1,
            transform: "translateY(0)"
        },
        {
            opacity: 0,
            transform: "translateY(-100%)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.showEnd", {
    keyframes: [
        {
            opacity: 0,
            transform: "translateX(100%)"
        },
        {
            opacity: 1,
            transform: "translateX(0)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.hideEnd", {
    keyframes: [
        {
            opacity: 1,
            transform: "translateX(0)"
        },
        {
            opacity: 0,
            transform: "translateX(100%)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.showBottom", {
    keyframes: [
        {
            opacity: 0,
            transform: "translateY(100%)"
        },
        {
            opacity: 1,
            transform: "translateY(0)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.hideBottom", {
    keyframes: [
        {
            opacity: 1,
            transform: "translateY(0)"
        },
        {
            opacity: 0,
            transform: "translateY(100%)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.showStart", {
    keyframes: [
        {
            opacity: 0,
            transform: "translateX(-100%)"
        },
        {
            opacity: 1,
            transform: "translateX(0)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.hideStart", {
    keyframes: [
        {
            opacity: 1,
            transform: "translateX(0)"
        },
        {
            opacity: 0,
            transform: "translateX(-100%)"
        }
    ],
    options: {
        duration: 250,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.denyClose", {
    keyframes: [
        {
            transform: "scale(1)"
        },
        {
            transform: "scale(1.01)"
        },
        {
            transform: "scale(1)"
        }
    ],
    options: {
        duration: 250
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.overlay.show", {
    keyframes: [
        {
            opacity: 0
        },
        {
            opacity: 1
        }
    ],
    options: {
        duration: 250
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("drawer.overlay.hide", {
    keyframes: [
        {
            opacity: 1
        },
        {
            opacity: 0
        }
    ],
    options: {
        duration: 250
    }
});

},{"./chunk.ZXQWYC2K.js":"luWMM","./chunk.SXNB3LL3.js":"cN7v8","./chunk.ST4GEPNZ.js":"ao9ex","./chunk.5TL5QPK4.js":"akO45","./chunk.6JY65IM5.js":"d40Fl","./chunk.UTEQRIIY.js":"h4h4P","./chunk.W2WMQSCE.js":"9o2tn","./chunk.KJOCH52Q.js":"e6TXF","./chunk.BD26TKS4.js":"1j2NX","./chunk.I4TE3TJV.js":"i4CGq","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"luWMM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawer_styles_default", ()=>drawer_styles_default
);
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/drawer/drawer.styles.ts
var drawer_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    --size: 25rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .drawer {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
  }

  .drawer--contained {
    position: absolute;
    z-index: initial;
  }

  .drawer--fixed {
    position: fixed;
    z-index: var(--sl-z-index-drawer);
  }

  .drawer__panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    z-index: 2;
    max-width: 100%;
    max-height: 100%;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-large);
    transition: var(--sl-transition-medium) transform;
    overflow: auto;
    pointer-events: all;
  }

  .drawer__panel:focus {
    outline: none;
  }

  .drawer--top .drawer__panel {
    top: 0;
    right: auto;
    bottom: auto;
    left: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--end .drawer__panel {
    top: 0;
    right: 0;
    bottom: auto;
    left: auto;
    width: var(--size);
    height: 100%;
  }

  .drawer--bottom .drawer__panel {
    top: auto;
    right: auto;
    bottom: 0;
    left: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--start .drawer__panel {
    top: 0;
    right: auto;
    bottom: auto;
    left: 0;
    width: var(--size);
    height: 100%;
  }

  .drawer__header {
    display: flex;
  }

  .drawer__title {
    flex: 1 1 auto;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
  }

  .drawer__close {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-x-large);
    padding: 0 var(--header-spacing);
  }

  .drawer__body {
    flex: 1 1 auto;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .drawer__footer {
    text-align: right;
    padding: var(--footer-spacing);
  }

  .drawer__footer ::slotted(sl-button:not(:last-of-type)) {
    margin-right: var(--sl-spacing-x-small);
  }

  .drawer:not(.drawer--has-footer) .drawer__footer {
    display: none;
  }

  .drawer__overlay {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
    pointer-events: all;
  }

  .drawer--contained .drawer__overlay {
    position: absolute;
  }
`;

},{"./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"le94t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunkIBSPWXHKJs.SlIcon
);
var _chunkIBSPWXHKJs = require("../../chunks/chunk.IBSPWXHK.js");
var _chunkL4IDTG64Js = require("../../chunks/chunk.L4IDTG64.js");
var _chunkC7PPQWMAJs = require("../../chunks/chunk.C7PPQWMA.js");
var _chunkNFF2HMITJs = require("../../chunks/chunk.NFF2HMIT.js");
var _chunkHEOUBJ7TJs = require("../../chunks/chunk.HEOUBJ7T.js");
var _chunkUJSH3WGMJs = require("../../chunks/chunk.UJSH3WGM.js");
var _chunk4KUWHA33Js = require("../../chunks/chunk.4KUWHA33.js");
var _chunkKJOCH52QJs = require("../../chunks/chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("../../chunks/chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.IBSPWXHK.js":"bRaa7","../../chunks/chunk.L4IDTG64.js":"5bB1j","../../chunks/chunk.C7PPQWMA.js":"szhSB","../../chunks/chunk.NFF2HMIT.js":"fX0do","../../chunks/chunk.HEOUBJ7T.js":"3YVet","../../chunks/chunk.UJSH3WGM.js":"7vHmo","../../chunks/chunk.4KUWHA33.js":"69rgo","../../chunks/chunk.KJOCH52Q.js":"e6TXF","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.BD26TKS4.js":"1j2NX","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3V6Ki":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunkBI66FINLJs.SlTabGroup
);
var _chunkBI66FINLJs = require("../../chunks/chunk.BI66FINL.js");
var _chunkJZCWPHAUJs = require("../../chunks/chunk.JZCWPHAU.js");
var _chunkCCTU25PVJs = require("../../chunks/chunk.CCTU25PV.js");
var _chunkST4GEPNZJs = require("../../chunks/chunk.ST4GEPNZ.js");
var _chunkQSLHMB3EJs = require("../../chunks/chunk.QSLHMB3E.js");
var _chunkWCAFNYXWJs = require("../../chunks/chunk.WCAFNYXW.js");
var _chunkW2WMQSCEJs = require("../../chunks/chunk.W2WMQSCE.js");
var _chunkAN2XMPAVJs = require("../../chunks/chunk.AN2XMPAV.js");
var _chunkIBSPWXHKJs = require("../../chunks/chunk.IBSPWXHK.js");
var _chunkL4IDTG64Js = require("../../chunks/chunk.L4IDTG64.js");
var _chunkC7PPQWMAJs = require("../../chunks/chunk.C7PPQWMA.js");
var _chunkNFF2HMITJs = require("../../chunks/chunk.NFF2HMIT.js");
var _chunkHEOUBJ7TJs = require("../../chunks/chunk.HEOUBJ7T.js");
var _chunkUJSH3WGMJs = require("../../chunks/chunk.UJSH3WGM.js");
var _chunk4KUWHA33Js = require("../../chunks/chunk.4KUWHA33.js");
var _chunkKJOCH52QJs = require("../../chunks/chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("../../chunks/chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.BI66FINL.js":"2TVnS","../../chunks/chunk.JZCWPHAU.js":"jNzoO","../../chunks/chunk.CCTU25PV.js":"dUPzH","../../chunks/chunk.ST4GEPNZ.js":"ao9ex","../../chunks/chunk.QSLHMB3E.js":"2Tw6u","../../chunks/chunk.WCAFNYXW.js":"9Qo42","../../chunks/chunk.W2WMQSCE.js":"9o2tn","../../chunks/chunk.AN2XMPAV.js":"2bW2A","../../chunks/chunk.IBSPWXHK.js":"bRaa7","../../chunks/chunk.L4IDTG64.js":"5bB1j","../../chunks/chunk.C7PPQWMA.js":"szhSB","../../chunks/chunk.NFF2HMIT.js":"fX0do","../../chunks/chunk.HEOUBJ7T.js":"3YVet","../../chunks/chunk.UJSH3WGM.js":"7vHmo","../../chunks/chunk.4KUWHA33.js":"69rgo","../../chunks/chunk.KJOCH52Q.js":"e6TXF","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.BD26TKS4.js":"1j2NX","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2TVnS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlTabGroup", ()=>SlTabGroup
);
var _chunkJZCWPHAUJs = require("./chunk.JZCWPHAU.js");
var _chunkCCTU25PVJs = require("./chunk.CCTU25PV.js");
var _chunkST4GEPNZJs = require("./chunk.ST4GEPNZ.js");
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkBD26TKS4Js = require("./chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("./chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/components/tab-group/tab-group.ts
var SlTabGroup = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.localize = new _chunkCCTU25PVJs.LocalizeController(this);
        this.tabs = [];
        this.panels = [];
        this.hasScrollControls = false;
        this.placement = "top";
        this.activation = "auto";
        this.noScrollControls = false;
    }
    connectedCallback() {
        super.connectedCallback();
        this.resizeObserver = new ResizeObserver(()=>{
            this.preventIndicatorTransition();
            this.repositionIndicator();
            this.updateScrollControls();
        });
        this.mutationObserver = new MutationObserver((mutations)=>{
            if (mutations.some((m)=>![
                    "aria-labelledby",
                    "aria-controls"
                ].includes(m.attributeName)
            )) setTimeout(()=>this.setAriaLabels()
            );
            if (mutations.some((m)=>m.attributeName === "disabled"
            )) this.syncTabsAndPanels();
        });
        this.updateComplete.then(()=>{
            this.syncTabsAndPanels();
            this.mutationObserver.observe(this, {
                attributes: true,
                childList: true,
                subtree: true
            });
            this.resizeObserver.observe(this.nav);
            const intersectionObserver = new IntersectionObserver((entries, observer)=>{
                if (entries[0].intersectionRatio > 0) {
                    this.setAriaLabels();
                    this.setActiveTab(this.getActiveTab() || this.tabs[0], {
                        emitEvents: false
                    });
                    observer.unobserve(entries[0].target);
                }
            });
            intersectionObserver.observe(this.tabGroup);
        });
    }
    disconnectedCallback() {
        this.mutationObserver.disconnect();
        this.resizeObserver.unobserve(this.nav);
    }
    show(panel) {
        const tab = this.tabs.find((el)=>el.panel === panel
        );
        if (tab) this.setActiveTab(tab, {
            scrollBehavior: "smooth"
        });
    }
    getAllTabs(includeDisabled = false) {
        const slot = this.shadowRoot.querySelector('slot[name="nav"]');
        return [
            ...slot.assignedElements()
        ].filter((el)=>{
            return includeDisabled ? el.tagName.toLowerCase() === "sl-tab" : el.tagName.toLowerCase() === "sl-tab" && !el.disabled;
        });
    }
    getAllPanels() {
        const slot = this.body.querySelector("slot");
        return [
            ...slot.assignedElements()
        ].filter((el)=>el.tagName.toLowerCase() === "sl-tab-panel"
        );
    }
    getActiveTab() {
        return this.tabs.find((el)=>el.active
        );
    }
    handleClick(event) {
        const target = event.target;
        const tab = target.closest("sl-tab");
        const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
        if (tabGroup !== this) return;
        if (tab) this.setActiveTab(tab, {
            scrollBehavior: "smooth"
        });
    }
    handleKeyDown(event) {
        const target = event.target;
        const tab = target.closest("sl-tab");
        const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
        if (tabGroup !== this) return;
        if ([
            "Enter",
            " "
        ].includes(event.key)) {
            if (tab) {
                this.setActiveTab(tab, {
                    scrollBehavior: "smooth"
                });
                event.preventDefault();
            }
        }
        if ([
            "ArrowLeft",
            "ArrowRight",
            "ArrowUp",
            "ArrowDown",
            "Home",
            "End"
        ].includes(event.key)) {
            const activeEl = document.activeElement;
            if (activeEl && activeEl.tagName.toLowerCase() === "sl-tab") {
                let index = this.tabs.indexOf(activeEl);
                if (event.key === "Home") index = 0;
                else if (event.key === "End") index = this.tabs.length - 1;
                else if ([
                    "top",
                    "bottom"
                ].includes(this.placement) && event.key === "ArrowLeft" || [
                    "start",
                    "end"
                ].includes(this.placement) && event.key === "ArrowUp") index = Math.max(0, index - 1);
                else if ([
                    "top",
                    "bottom"
                ].includes(this.placement) && event.key === "ArrowRight" || [
                    "start",
                    "end"
                ].includes(this.placement) && event.key === "ArrowDown") index = Math.min(this.tabs.length - 1, index + 1);
                this.tabs[index].focus({
                    preventScroll: true
                });
                if (this.activation === "auto") this.setActiveTab(this.tabs[index], {
                    scrollBehavior: "smooth"
                });
                if ([
                    "top",
                    "bottom"
                ].includes(this.placement)) _chunkST4GEPNZJs.scrollIntoView(this.tabs[index], this.nav, "horizontal");
                event.preventDefault();
            }
        }
    }
    handleScrollToStart() {
        this.nav.scroll({
            left: this.nav.scrollLeft - this.nav.clientWidth,
            behavior: "smooth"
        });
    }
    handleScrollToEnd() {
        this.nav.scroll({
            left: this.nav.scrollLeft + this.nav.clientWidth,
            behavior: "smooth"
        });
    }
    updateScrollControls() {
        if (this.nav) {
            if (this.noScrollControls) this.hasScrollControls = false;
            else this.hasScrollControls = [
                "top",
                "bottom"
            ].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth;
        }
    }
    setActiveTab(tab, options) {
        options = Object.assign({
            emitEvents: true,
            scrollBehavior: "auto"
        }, options);
        if (tab && tab !== this.activeTab && !tab.disabled) {
            const previousTab = this.activeTab;
            this.activeTab = tab;
            this.tabs.map((el)=>el.active = el === this.activeTab
            );
            this.panels.map((el)=>el.active = el.name === this.activeTab.panel
            );
            this.syncIndicator();
            if ([
                "top",
                "bottom"
            ].includes(this.placement)) _chunkST4GEPNZJs.scrollIntoView(this.activeTab, this.nav, "horizontal", options.scrollBehavior);
            if (options.emitEvents) {
                if (previousTab) _chunkI4TE3TJVJs.emit(this, "sl-tab-hide", {
                    detail: {
                        name: previousTab.panel
                    }
                });
                _chunkI4TE3TJVJs.emit(this, "sl-tab-show", {
                    detail: {
                        name: this.activeTab.panel
                    }
                });
            }
        }
    }
    setAriaLabels() {
        this.tabs.map((tab)=>{
            const panel = this.panels.find((el)=>el.name === tab.panel
            );
            if (panel) {
                tab.setAttribute("aria-controls", panel.getAttribute("id"));
                panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
            }
        });
    }
    syncIndicator() {
        if (this.indicator) {
            const tab = this.getActiveTab();
            if (tab) {
                this.indicator.style.display = "block";
                this.repositionIndicator();
            } else {
                this.indicator.style.display = "none";
                return;
            }
        }
    }
    repositionIndicator() {
        const currentTab = this.getActiveTab();
        if (!currentTab) return;
        const width = currentTab.clientWidth;
        const height = currentTab.clientHeight;
        const offset = _chunkST4GEPNZJs.getOffset(currentTab, this.nav);
        const offsetTop = offset.top + this.nav.scrollTop;
        const offsetLeft = offset.left + this.nav.scrollLeft;
        switch(this.placement){
            case "top":
            case "bottom":
                this.indicator.style.width = `${width}px`;
                this.indicator.style.height = "auto";
                this.indicator.style.transform = `translateX(${offsetLeft}px)`;
                break;
            case "start":
            case "end":
                this.indicator.style.width = "auto";
                this.indicator.style.height = `${height}px`;
                this.indicator.style.transform = `translateY(${offsetTop}px)`;
                break;
        }
    }
    preventIndicatorTransition() {
        const transitionValue = this.indicator.style.transition;
        this.indicator.style.transition = "none";
        requestAnimationFrame(()=>{
            this.indicator.style.transition = transitionValue;
        });
    }
    syncTabsAndPanels() {
        this.tabs = this.getAllTabs();
        this.panels = this.getAllPanels();
        this.syncIndicator();
    }
    render() {
        return _chunk2VBMOEKGJs.$`
      <div
        part="base"
        class=${_chunkW2WMQSCEJs.o({
            "tab-group": true,
            "tab-group--top": this.placement === "top",
            "tab-group--bottom": this.placement === "bottom",
            "tab-group--start": this.placement === "start",
            "tab-group--end": this.placement === "end",
            "tab-group--has-scroll-controls": this.hasScrollControls
        })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? _chunk2VBMOEKGJs.$`
                <sl-icon-button
                  class="tab-group__scroll-button tab-group__scroll-button--start"
                  exportparts="base:scroll-button"
                  name="chevron-left"
                  library="system"
                  label=${this.localize.term("scroll_to_start")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav">
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
            </div>
          </div>

          ${this.hasScrollControls ? _chunk2VBMOEKGJs.$`
                <sl-icon-button
                  class="tab-group__scroll-button tab-group__scroll-button--end"
                  exportparts="base:scroll-button"
                  name="chevron-right"
                  library="system"
                  label=${this.localize.term("scroll_to_end")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <div part="body" class="tab-group__body">
          <slot @slotchange=${this.syncTabsAndPanels}></slot>
        </div>
      </div>
    `;
    }
};
SlTabGroup.styles = _chunkJZCWPHAUJs.tab_group_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".tab-group")
], SlTabGroup.prototype, "tabGroup", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".tab-group__body")
], SlTabGroup.prototype, "body", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".tab-group__nav")
], SlTabGroup.prototype, "nav", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".tab-group__indicator")
], SlTabGroup.prototype, "indicator", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.t()
], SlTabGroup.prototype, "hasScrollControls", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlTabGroup.prototype, "placement", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlTabGroup.prototype, "activation", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        attribute: "no-scroll-controls",
        type: Boolean
    })
], SlTabGroup.prototype, "noScrollControls", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlTabGroup.prototype, "lang", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("noScrollControls")
], SlTabGroup.prototype, "updateScrollControls", 1);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("placement")
], SlTabGroup.prototype, "syncIndicator", 1);
SlTabGroup = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-tab-group")
], SlTabGroup);

},{"./chunk.JZCWPHAU.js":"jNzoO","./chunk.CCTU25PV.js":"dUPzH","./chunk.ST4GEPNZ.js":"ao9ex","./chunk.W2WMQSCE.js":"9o2tn","./chunk.BD26TKS4.js":"1j2NX","./chunk.I4TE3TJV.js":"i4CGq","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jNzoO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tab_group_styles_default", ()=>tab_group_styles_default
);
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/tab-group/tab-group.styles.ts
var tab_group_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    --track-color: var(--sl-color-neutral-200);
    --indicator-color: var(--sl-color-primary-600);

    display: block;
  }

  .tab-group {
    display: flex;
    border: solid 1px transparent;
    border-radius: 0;
  }

  .tab-group .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group .tab-group__indicator {
    position: absolute;
    left: 0;
    transition: var(--sl-transition-fast) transform ease, var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid 2px var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: -2px;
    border-bottom: solid 2px var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid 2px var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * 2px);
    border-top: solid 2px var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-right: solid 2px var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * 2px);
    border-right: solid 2px var(--indicator-color);
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid 2px var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * 2px);
    border-left: solid 2px var(--indicator-color);
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;

},{"./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dUPzH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "en_default", ()=>en_default
);
parcelHelpers.export(exports, "registerTranslation", ()=>registerTranslation
);
parcelHelpers.export(exports, "term", ()=>term
);
parcelHelpers.export(exports, "date", ()=>date
);
parcelHelpers.export(exports, "number", ()=>number
);
parcelHelpers.export(exports, "relativeTime", ()=>relativeTime
);
parcelHelpers.export(exports, "update", ()=>update
);
parcelHelpers.export(exports, "LocalizeController", ()=>LocalizeController
);
// node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var documentElementObserver = new MutationObserver(update);
var translations = /* @__PURE__ */ new Map();
var documentLanguage = document.documentElement.lang || navigator.language;
var fallback;
documentElementObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: [
        "lang"
    ]
});
function registerTranslation(...translation2) {
    translation2.map((t)=>{
        const code = t.$code.toLowerCase();
        translations.set(code, t);
        if (!fallback) fallback = t;
    });
    update();
}
function term(lang, key, ...args) {
    const code = lang.toLowerCase().slice(0, 2);
    const subcode = lang.length > 2 ? lang.toLowerCase() : "";
    const primary = translations.get(subcode);
    const secondary = translations.get(code);
    let term2;
    if (primary && primary[key]) term2 = primary[key];
    else if (secondary && secondary[key]) term2 = secondary[key];
    else if (fallback && fallback[key]) term2 = fallback[key];
    else {
        console.error(`No translation found for: ${key}`);
        return key;
    }
    if (typeof term2 === "function") return term2(...args);
    return term2;
}
function date(lang, dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(lang, options).format(dateToFormat);
}
function number(lang, numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(lang, options).format(numberToFormat);
}
function relativeTime(lang, value, unit, options) {
    return new Intl.RelativeTimeFormat(lang, options).format(value, unit);
}
function update() {
    documentLanguage = document.documentElement.lang || navigator.language;
    [
        ...connectedElements.keys()
    ].map((el)=>{
        if (typeof el.requestUpdate === "function") el.requestUpdate();
    });
}
var LocalizeController = class {
    constructor(host){
        this.host = host;
        this.host.addController(this);
    }
    hostConnected() {
        connectedElements.add(this.host);
    }
    hostDisconnected() {
        connectedElements.delete(this.host);
    }
    term(key, ...args) {
        return term(this.host.lang || documentLanguage, key, ...args);
    }
    date(dateToFormat, options) {
        return date(this.host.lang || documentLanguage, dateToFormat, options);
    }
    number(numberToFormat, options) {
        return number(this.host.lang || documentLanguage, numberToFormat, options);
    }
    relativeTime(value, unit, options) {
        return relativeTime(this.host.lang || documentLanguage, value, unit, options);
    }
};
// src/translations/en.ts
var translation = {
    $code: "en",
    $name: "English",
    $dir: "ltr",
    close: "Close",
    copy: "Copy",
    progress: "Progress",
    resize: "Resize",
    scroll_to_end: "Scroll to end",
    scroll_to_start: "Scroll to start",
    select_a_color_from_the_screen: "Select a color from the screen",
    toggle_color_format: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7mIsr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunk4SFIXTCNJs.SlTabPanel
);
var _chunk4SFIXTCNJs = require("../../chunks/chunk.4SFIXTCN.js");
var _chunkKMV7CIIKJs = require("../../chunks/chunk.KMV7CIIK.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.4SFIXTCN.js":"ltQbx","../../chunks/chunk.KMV7CIIK.js":"fIvnX","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltQbx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlTabPanel", ()=>SlTabPanel
);
var _chunkKMV7CIIKJs = require("./chunk.KMV7CIIK.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/components/tab-panel/tab-panel.ts
var id = 0;
var SlTabPanel = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.componentId = `sl-tab-panel-${++id}`;
        this.name = "";
        this.active = false;
    }
    connectedCallback() {
        super.connectedCallback();
        this.id = this.id || this.componentId;
    }
    render() {
        this.style.display = this.active ? "block" : "none";
        return _chunk2VBMOEKGJs.$`
      <div part="base" class="tab-panel" role="tabpanel" aria-hidden=${this.active ? "false" : "true"}>
        <slot></slot>
      </div>
    `;
    }
};
SlTabPanel.styles = _chunkKMV7CIIKJs.tab_panel_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        reflect: true
    })
], SlTabPanel.prototype, "name", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlTabPanel.prototype, "active", 2);
SlTabPanel = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-tab-panel")
], SlTabPanel);

},{"./chunk.KMV7CIIK.js":"fIvnX","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fIvnX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tab_panel_styles_default", ()=>tab_panel_styles_default
);
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/tab-panel/tab-panel.styles.ts
var tab_panel_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    --padding: 0;

    display: block;
  }

  .tab-panel {
    border: solid 1px transparent;
    padding: var(--padding);
  }
`;

},{"./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hsPiV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunkZ73GCS7XJs.SlTab
);
var _chunkZ73GCS7XJs = require("../../chunks/chunk.Z73GCS7X.js");
var _chunk7O2OK7EMJs = require("../../chunks/chunk.7O2OK7EM.js");
var _chunkCCTU25PVJs = require("../../chunks/chunk.CCTU25PV.js");
var _chunkQSLHMB3EJs = require("../../chunks/chunk.QSLHMB3E.js");
var _chunkWCAFNYXWJs = require("../../chunks/chunk.WCAFNYXW.js");
var _chunkW2WMQSCEJs = require("../../chunks/chunk.W2WMQSCE.js");
var _chunkAN2XMPAVJs = require("../../chunks/chunk.AN2XMPAV.js");
var _chunkIBSPWXHKJs = require("../../chunks/chunk.IBSPWXHK.js");
var _chunkL4IDTG64Js = require("../../chunks/chunk.L4IDTG64.js");
var _chunkC7PPQWMAJs = require("../../chunks/chunk.C7PPQWMA.js");
var _chunkNFF2HMITJs = require("../../chunks/chunk.NFF2HMIT.js");
var _chunkHEOUBJ7TJs = require("../../chunks/chunk.HEOUBJ7T.js");
var _chunkUJSH3WGMJs = require("../../chunks/chunk.UJSH3WGM.js");
var _chunk4KUWHA33Js = require("../../chunks/chunk.4KUWHA33.js");
var _chunkKJOCH52QJs = require("../../chunks/chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("../../chunks/chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.Z73GCS7X.js":"bC632","../../chunks/chunk.7O2OK7EM.js":"lMIIV","../../chunks/chunk.CCTU25PV.js":"dUPzH","../../chunks/chunk.QSLHMB3E.js":"2Tw6u","../../chunks/chunk.WCAFNYXW.js":"9Qo42","../../chunks/chunk.W2WMQSCE.js":"9o2tn","../../chunks/chunk.AN2XMPAV.js":"2bW2A","../../chunks/chunk.IBSPWXHK.js":"bRaa7","../../chunks/chunk.L4IDTG64.js":"5bB1j","../../chunks/chunk.C7PPQWMA.js":"szhSB","../../chunks/chunk.NFF2HMIT.js":"fX0do","../../chunks/chunk.HEOUBJ7T.js":"3YVet","../../chunks/chunk.UJSH3WGM.js":"7vHmo","../../chunks/chunk.4KUWHA33.js":"69rgo","../../chunks/chunk.KJOCH52Q.js":"e6TXF","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.BD26TKS4.js":"1j2NX","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bC632":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlTab", ()=>SlTab
);
var _chunk7O2OK7EMJs = require("./chunk.7O2OK7EM.js");
var _chunkCCTU25PVJs = require("./chunk.CCTU25PV.js");
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkI4TE3TJVJs = require("./chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/components/tab/tab.ts
var id = 0;
var SlTab = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.localize = new _chunkCCTU25PVJs.LocalizeController(this);
        this.componentId = `sl-tab-${++id}`;
        this.panel = "";
        this.active = false;
        this.closable = false;
        this.disabled = false;
    }
    focus(options) {
        this.tab.focus(options);
    }
    blur() {
        this.tab.blur();
    }
    handleCloseClick() {
        _chunkI4TE3TJVJs.emit(this, "sl-close");
    }
    render() {
        this.id = this.id || this.componentId;
        return _chunk2VBMOEKGJs.$`
      <div
        part="base"
        class=${_chunkW2WMQSCEJs.o({
            tab: true,
            "tab--active": this.active,
            "tab--closable": this.closable,
            "tab--disabled": this.disabled
        })}
        role="tab"
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-selected=${this.active ? "true" : "false"}
        tabindex=${this.disabled || !this.active ? "-1" : "0"}
      >
        <slot></slot>
        ${this.closable ? _chunk2VBMOEKGJs.$`
              <sl-icon-button
                name="x"
                library="system"
                label=${this.localize.term("close")}
                exportparts="base:close-button"
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
    }
};
SlTab.styles = _chunk7O2OK7EMJs.tab_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".tab")
], SlTab.prototype, "tab", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        reflect: true
    })
], SlTab.prototype, "panel", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlTab.prototype, "active", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean
    })
], SlTab.prototype, "closable", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlTab.prototype, "disabled", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlTab.prototype, "lang", 2);
SlTab = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-tab")
], SlTab);

},{"./chunk.7O2OK7EM.js":"lMIIV","./chunk.CCTU25PV.js":"dUPzH","./chunk.W2WMQSCE.js":"9o2tn","./chunk.I4TE3TJV.js":"i4CGq","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lMIIV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tab_styles_default", ()=>tab_styles_default
);
var _chunkAN2XMPAVJs = require("./chunk.AN2XMPAV.js");
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/tab/tab.styles.ts
var tab_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    cursor: pointer;
    transition: var(--transition-speed) box-shadow, var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus {
    outline: none;
  }

  .tab${_chunkAN2XMPAVJs.focusVisibleSelector}:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
    box-shadow: inset var(--sl-focus-ring);
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-right: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-large);
    margin-left: var(--sl-spacing-2x-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }
`;

},{"./chunk.AN2XMPAV.js":"2bW2A","./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6RAKh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunk3O6HBCDCJs.SlTooltip
);
var _chunk3O6HBCDCJs = require("../../chunks/chunk.3O6HBCDC.js");
var _chunkV2N6BIOEJs = require("../../chunks/chunk.V2N6BIOE.js");
var _chunkMMVA6LRDJs = require("../../chunks/chunk.MMVA6LRD.js");
var _chunk6JY65IM5Js = require("../../chunks/chunk.6JY65IM5.js");
var _chunkUTEQRIIYJs = require("../../chunks/chunk.UTEQRIIY.js");
var _chunkW2WMQSCEJs = require("../../chunks/chunk.W2WMQSCE.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("../../chunks/chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.3O6HBCDC.js":"bxfJL","../../chunks/chunk.V2N6BIOE.js":"e9KlZ","../../chunks/chunk.MMVA6LRD.js":"gVisE","../../chunks/chunk.6JY65IM5.js":"d40Fl","../../chunks/chunk.UTEQRIIY.js":"h4h4P","../../chunks/chunk.W2WMQSCE.js":"9o2tn","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.BD26TKS4.js":"1j2NX","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bxfJL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlTooltip", ()=>SlTooltip
);
var _chunkV2N6BIOEJs = require("./chunk.V2N6BIOE.js");
var _chunkMMVA6LRDJs = require("./chunk.MMVA6LRD.js");
var _chunk6JY65IM5Js = require("./chunk.6JY65IM5.js");
var _chunkUTEQRIIYJs = require("./chunk.UTEQRIIY.js");
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkBD26TKS4Js = require("./chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("./chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/components/tooltip/tooltip.ts
var SlTooltip = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.content = "";
        this.placement = "top";
        this.disabled = false;
        this.distance = 10;
        this.open = false;
        this.skidding = 0;
        this.trigger = "hover focus";
        this.hoist = false;
    }
    connectedCallback() {
        super.connectedCallback();
        this.handleBlur = this.handleBlur.bind(this);
        this.handleClick = this.handleClick.bind(this);
        this.handleFocus = this.handleFocus.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleMouseOver = this.handleMouseOver.bind(this);
        this.handleMouseOut = this.handleMouseOut.bind(this);
        this.updateComplete.then(()=>{
            this.addEventListener("blur", this.handleBlur, true);
            this.addEventListener("focus", this.handleFocus, true);
            this.addEventListener("click", this.handleClick);
            this.addEventListener("keydown", this.handleKeyDown);
            this.addEventListener("mouseover", this.handleMouseOver);
            this.addEventListener("mouseout", this.handleMouseOut);
            this.target = this.getTarget();
            this.syncOptions();
        });
    }
    firstUpdated() {
        this.tooltip.hidden = !this.open;
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("blur", this.handleBlur, true);
        this.removeEventListener("focus", this.handleFocus, true);
        this.removeEventListener("click", this.handleClick);
        this.removeEventListener("keydown", this.handleKeyDown);
        this.removeEventListener("mouseover", this.handleMouseOver);
        this.removeEventListener("mouseout", this.handleMouseOut);
        if (this.popover) this.popover.destroy();
    }
    async show() {
        if (this.open) return;
        this.open = true;
        return _chunkI4TE3TJVJs.waitForEvent(this, "sl-after-show");
    }
    async hide() {
        if (!this.open) return;
        this.open = false;
        return _chunkI4TE3TJVJs.waitForEvent(this, "sl-after-hide");
    }
    getTarget() {
        const target = [
            ...this.children
        ].find((el)=>el.tagName.toLowerCase() !== "style" && el.getAttribute("slot") !== "content"
        );
        if (!target) throw new Error("Invalid tooltip target: no child element was found.");
        return target;
    }
    handleBlur() {
        if (this.hasTrigger("focus")) this.hide();
    }
    handleClick() {
        if (this.hasTrigger("click")) this.open ? this.hide() : this.show();
    }
    handleFocus() {
        if (this.hasTrigger("focus")) this.show();
    }
    handleKeyDown(event) {
        if (this.open && event.key === "Escape") {
            event.stopPropagation();
            this.hide();
        }
    }
    handleMouseOver() {
        if (this.hasTrigger("hover")) {
            const delay = _chunk6JY65IM5Js.parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
            clearTimeout(this.hoverTimeout);
            this.hoverTimeout = setTimeout(()=>this.show()
            , delay);
        }
    }
    handleMouseOut() {
        if (this.hasTrigger("hover")) {
            const delay = _chunk6JY65IM5Js.parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
            clearTimeout(this.hoverTimeout);
            this.hoverTimeout = setTimeout(()=>this.hide()
            , delay);
        }
    }
    async handleOpenChange() {
        if (this.disabled) return;
        if (this.open) {
            _chunkI4TE3TJVJs.emit(this, "sl-show");
            await _chunk6JY65IM5Js.stopAnimations(this.tooltip);
            if (this.popover) this.popover.destroy();
            this.popover = _chunkMMVA6LRDJs.createPopper(this.target, this.positioner, {
                placement: this.placement,
                strategy: this.hoist ? "fixed" : "absolute",
                modifiers: [
                    {
                        name: "flip",
                        options: {
                            boundary: "viewport"
                        }
                    },
                    {
                        name: "offset",
                        options: {
                            offset: [
                                this.skidding,
                                this.distance
                            ]
                        }
                    }
                ]
            });
            this.tooltip.hidden = false;
            const { keyframes , options  } = _chunkUTEQRIIYJs.getAnimation(this, "tooltip.show");
            await _chunk6JY65IM5Js.animateTo(this.tooltip, keyframes, options);
            _chunkI4TE3TJVJs.emit(this, "sl-after-show");
        } else {
            _chunkI4TE3TJVJs.emit(this, "sl-hide");
            await _chunk6JY65IM5Js.stopAnimations(this.tooltip);
            const { keyframes , options  } = _chunkUTEQRIIYJs.getAnimation(this, "tooltip.hide");
            await _chunk6JY65IM5Js.animateTo(this.tooltip, keyframes, options);
            this.tooltip.hidden = true;
            if (this.popover) this.popover.destroy();
            _chunkI4TE3TJVJs.emit(this, "sl-after-hide");
        }
    }
    handleOptionsChange() {
        this.syncOptions();
    }
    handleContentChange() {
        if (this.popover && this.open) this.popover.update();
    }
    handleDisabledChange() {
        if (this.disabled && this.open) this.hide();
    }
    hasTrigger(triggerType) {
        const triggers = this.trigger.split(" ");
        return triggers.includes(triggerType);
    }
    syncOptions() {
        if (this.popover) this.popover.setOptions({
            placement: this.placement,
            strategy: this.hoist ? "fixed" : "absolute",
            modifiers: [
                {
                    name: "flip",
                    options: {
                        boundary: "viewport"
                    }
                },
                {
                    name: "offset",
                    options: {
                        offset: [
                            this.skidding,
                            this.distance
                        ]
                    }
                }
            ]
        });
    }
    render() {
        return _chunk2VBMOEKGJs.$`
      <div class="tooltip-content" aria-described-by="tooltip">
        <slot></slot>
      </div>

      <div class="tooltip-positioner">
        <div
          part="base"
          id="tooltip"
          class=${_chunkW2WMQSCEJs.o({
            tooltip: true,
            "tooltip--open": this.open
        })}
          role="tooltip"
          aria-hidden=${this.open ? "false" : "true"}
        >
          <slot name="content"> ${this.content} </slot>
        </div>
      </div>
    `;
    }
};
SlTooltip.styles = _chunkV2N6BIOEJs.tooltip_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".tooltip-positioner")
], SlTooltip.prototype, "positioner", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i(".tooltip")
], SlTooltip.prototype, "tooltip", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlTooltip.prototype, "content", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlTooltip.prototype, "placement", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlTooltip.prototype, "disabled", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Number
    })
], SlTooltip.prototype, "distance", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlTooltip.prototype, "open", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Number
    })
], SlTooltip.prototype, "skidding", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlTooltip.prototype, "trigger", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean
    })
], SlTooltip.prototype, "hoist", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("open", {
        waitUntilFirstUpdate: true
    })
], SlTooltip.prototype, "handleOpenChange", 1);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("placement"),
    _chunkBD26TKS4Js.watch("distance"),
    _chunkBD26TKS4Js.watch("skidding"),
    _chunkBD26TKS4Js.watch("hoist")
], SlTooltip.prototype, "handleOptionsChange", 1);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("content")
], SlTooltip.prototype, "handleContentChange", 1);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("disabled")
], SlTooltip.prototype, "handleDisabledChange", 1);
SlTooltip = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-tooltip")
], SlTooltip);
_chunkUTEQRIIYJs.setDefaultAnimation("tooltip.show", {
    keyframes: [
        {
            opacity: 0,
            transform: "scale(0.8)"
        },
        {
            opacity: 1,
            transform: "scale(1)"
        }
    ],
    options: {
        duration: 150,
        easing: "ease"
    }
});
_chunkUTEQRIIYJs.setDefaultAnimation("tooltip.hide", {
    keyframes: [
        {
            opacity: 1,
            transform: "scale(1)"
        },
        {
            opacity: 0,
            transform: "scale(0.8)"
        }
    ],
    options: {
        duration: 150,
        easing: "ease"
    }
});

},{"./chunk.V2N6BIOE.js":"e9KlZ","./chunk.MMVA6LRD.js":"gVisE","./chunk.6JY65IM5.js":"d40Fl","./chunk.UTEQRIIY.js":"h4h4P","./chunk.W2WMQSCE.js":"9o2tn","./chunk.BD26TKS4.js":"1j2NX","./chunk.I4TE3TJV.js":"i4CGq","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e9KlZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tooltip_styles_default", ()=>tooltip_styles_default
);
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/tooltip/tooltip.styles.ts
var tooltip_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip-content {
    display: contents;
  }

  .tooltip-positioner {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    pointer-events: none;
  }

  .tooltip {
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
  }

  .tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
  }

  .tooltip-positioner[data-popper-placement^='top'] .tooltip {
    transform-origin: bottom;
  }

  .tooltip-positioner[data-popper-placement^='bottom'] .tooltip {
    transform-origin: top;
  }

  .tooltip-positioner[data-popper-placement^='left'] .tooltip {
    transform-origin: right;
  }

  .tooltip-positioner[data-popper-placement^='right'] .tooltip {
    transform-origin: left;
  }

  /* Arrow + bottom */
  .tooltip-positioner[data-popper-placement^='bottom'] .tooltip:after {
    bottom: 100%;
    left: calc(50% - var(--sl-tooltip-arrow-size));
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
  }

  .tooltip-positioner[data-popper-placement='bottom-start'] .tooltip:after {
    left: var(--sl-tooltip-arrow-start-end-offset);
  }

  .tooltip-positioner[data-popper-placement='bottom-end'] .tooltip:after {
    right: var(--sl-tooltip-arrow-start-end-offset);
    left: auto;
  }

  /* Arrow + top */
  .tooltip-positioner[data-popper-placement^='top'] .tooltip:after {
    top: 100%;
    left: calc(50% - var(--sl-tooltip-arrow-size));
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
  }

  .tooltip-positioner[data-popper-placement='top-start'] .tooltip:after {
    left: var(--sl-tooltip-arrow-start-end-offset);
  }

  .tooltip-positioner[data-popper-placement='top-end'] .tooltip:after {
    right: var(--sl-tooltip-arrow-start-end-offset);
    left: auto;
  }

  /* Arrow + left */
  .tooltip-positioner[data-popper-placement^='left'] .tooltip:after {
    top: calc(50% - var(--sl-tooltip-arrow-size));
    left: 100%;
    border-left: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-top: var(--sl-tooltip-arrow-size) solid transparent;
    border-bottom: var(--sl-tooltip-arrow-size) solid transparent;
  }

  .tooltip-positioner[data-popper-placement='left-start'] .tooltip:after {
    top: var(--sl-tooltip-arrow-start-end-offset);
  }

  .tooltip-positioner[data-popper-placement='left-end'] .tooltip:after {
    top: auto;
    bottom: var(--sl-tooltip-arrow-start-end-offset);
  }

  /* Arrow + right */
  .tooltip-positioner[data-popper-placement^='right'] .tooltip:after {
    top: calc(50% - var(--sl-tooltip-arrow-size));
    right: 100%;
    border-right: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-top: var(--sl-tooltip-arrow-size) solid transparent;
    border-bottom: var(--sl-tooltip-arrow-size) solid transparent;
  }

  .tooltip-positioner[data-popper-placement='right-start'] .tooltip:after {
    top: var(--sl-tooltip-arrow-start-end-offset);
  }

  .tooltip-positioner[data-popper-placement='right-end'] .tooltip:after {
    top: auto;
    bottom: var(--sl-tooltip-arrow-start-end-offset);
  }
`;

},{"./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gVisE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopper", ()=>createPopper
);
// node_modules/@popperjs/core/dist/esm/dom-utils/getWindow.js
function getWindow(node) {
    if (node == null) return window;
    if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}
// node_modules/@popperjs/core/dist/esm/dom-utils/instanceOf.js
function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") return false;
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}
// node_modules/@popperjs/core/dist/esm/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;
// node_modules/@popperjs/core/dist/esm/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) includeScale = false;
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (isHTMLElement(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth;
        if (offsetWidth > 0) scaleX = round(rect.width) / offsetWidth || 1;
        if (offsetHeight > 0) scaleY = round(rect.height) / offsetHeight || 1;
    }
    return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
    };
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft,
        scrollTop
    };
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) return getWindowScroll(node);
    else return getHTMLElementScroll(node);
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getNodeName.js
function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
}
// node_modules/@popperjs/core/dist/esm/dom-utils/isScrollParent.js
function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getCompositeRect.js
function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) isFixed = false;
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) scroll = getNodeScroll(offsetParent);
        if (isHTMLElement(offsetParent)) {
            offsets = getBoundingClientRect(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) offsets.x = getWindowScrollBarX(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
    if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width,
        height
    };
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getParentNode.js
function getParentNode(element) {
    if (getNodeName(element) === "html") return element;
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getScrollParent.js
function getScrollParent(node) {
    if ([
        "html",
        "body",
        "#document"
    ].indexOf(getNodeName(node)) >= 0) return node.ownerDocument.body;
    if (isHTMLElement(node) && isScrollParent(node)) return node;
    return getScrollParent(getParentNode(node));
}
// node_modules/@popperjs/core/dist/esm/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) list = [];
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [
        win
    ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
// node_modules/@popperjs/core/dist/esm/dom-utils/isTableElement.js
function isTableElement(element) {
    return [
        "table",
        "td",
        "th"
    ].indexOf(getNodeName(element)) >= 0;
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") return null;
    return element.offsetParent;
}
function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle(element);
        if (elementCss.position === "fixed") return null;
    }
    var currentNode = getParentNode(element);
    while(isHTMLElement(currentNode) && [
        "html",
        "body"
    ].indexOf(getNodeName(currentNode)) < 0){
        var css = getComputedStyle(currentNode);
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || [
            "transform",
            "perspective"
        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") return currentNode;
        else currentNode = currentNode.parentNode;
    }
    return null;
}
function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static")offsetParent = getTrueOffsetParent(offsetParent);
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) return window2;
    return offsetParent || getContainingBlock(element) || window2;
}
// node_modules/@popperjs/core/dist/esm/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [
    top,
    bottom,
    right,
    left
];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [
    auto
]).reduce(function(acc, placement) {
    return acc.concat([
        placement,
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite
];
// node_modules/@popperjs/core/dist/esm/utils/orderModifiers.js
function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
    });
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) sort(depModifier);
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) sort(modifier);
    });
    return result;
}
function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
        }));
    }, []);
}
// node_modules/@popperjs/core/dist/esm/utils/debounce.js
function debounce(fn2) {
    var pending;
    return function() {
        if (!pending) pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
                pending = void 0;
                resolve(fn2());
            });
        });
        return pending;
    };
}
// node_modules/@popperjs/core/dist/esm/utils/getBasePlacement.js
function getBasePlacement(placement) {
    return placement.split("-")[0];
}
// node_modules/@popperjs/core/dist/esm/utils/mergeByName.js
function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({
        }, existing, current, {
            options: Object.assign({
            }, existing.options, current.options),
            data: Object.assign({
            }, existing.data, current.data)
        }) : current;
        return merged2;
    }, {
    });
    return Object.keys(merged).map(function(key) {
        return merged[key];
    });
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getViewportRect.js
function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width,
        height,
        x: x + getWindowScrollBarX(element),
        y
    };
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle(body || html).direction === "rtl") x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    return {
        width,
        height,
        x,
        y
    };
}
// node_modules/@popperjs/core/dist/esm/dom-utils/contains.js
function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) return true;
    else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
            if (next && parent.isSameNode(next)) return true;
            next = next.parentNode || next.host;
        }while (next)
    }
    return false;
}
// node_modules/@popperjs/core/dist/esm/utils/rectToClientRect.js
function rectToClientRect(rect) {
    return Object.assign({
    }, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    });
}
// node_modules/@popperjs/core/dist/esm/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = [
        "absolute",
        "fixed"
    ].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) return [];
    return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
}
function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [
        rootBoundary
    ]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}
// node_modules/@popperjs/core/dist/esm/utils/getVariation.js
function getVariation(placement) {
    return placement.split("-")[1];
}
// node_modules/@popperjs/core/dist/esm/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
    return [
        "top",
        "bottom"
    ].indexOf(placement) >= 0 ? "x" : "y";
}
// node_modules/@popperjs/core/dist/esm/utils/computeOffsets.js
function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch(basePlacement){
        case top:
            offsets = {
                x: commonX,
                y: reference2.y - element.height
            };
            break;
        case bottom:
            offsets = {
                x: commonX,
                y: reference2.y + reference2.height
            };
            break;
        case right:
            offsets = {
                x: reference2.x + reference2.width,
                y: commonY
            };
            break;
        case left:
            offsets = {
                x: reference2.x - element.width,
                y: commonY
            };
            break;
        default:
            offsets = {
                x: reference2.x,
                y: reference2.y
            };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch(variation){
            case start:
                offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
                break;
            case end:
                offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
                break;
            default:
        }
    }
    return offsets;
}
// node_modules/@popperjs/core/dist/esm/utils/getFreshSideObject.js
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };
}
// node_modules/@popperjs/core/dist/esm/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
    return Object.assign({
    }, getFreshSideObject(), paddingObject);
}
// node_modules/@popperjs/core/dist/esm/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {
    });
}
// node_modules/@popperjs/core/dist/esm/utils/detectOverflow.js
function detectOverflow(state, options) {
    if (options === void 0) options = {
    };
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
    });
    var popperClientRect = rectToClientRect(Object.assign({
    }, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [
                right,
                bottom
            ].indexOf(key) >= 0 ? 1 : -1;
            var axis = [
                top,
                bottom
            ].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset2[axis] * multiply;
        });
    }
    return overflowOffsets;
}
// node_modules/@popperjs/core/dist/esm/createPopper.js
var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function areValidElements() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
    });
}
function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) generatorOptions = {
    };
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
        if (options === void 0) options = defaultOptions;
        var state = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({
            }, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {
            },
            elements: {
                reference: reference2,
                popper: popper2
            },
            attributes: {
            },
            styles: {
            }
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state,
            setOptions: function setOptions(setOptionsAction) {
                var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                cleanupModifierEffects();
                state.options = Object.assign({
                }, defaultOptions, state.options, options2);
                state.scrollParents = {
                    reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
                    popper: listScrollParents(popper2)
                };
                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
                state.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                });
                var modifiers, _ref, name, flipModifier, _ref2, name1, _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, margin;
                runModifierEffects();
                return instance.update();
            },
            forceUpdate: function forceUpdate() {
                if (isDestroyed) return;
                var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
                if (!areValidElements(reference3, popper3)) return;
                state.rects = {
                    reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
                    popper: getLayoutRect(popper3)
                };
                state.reset = false;
                state.placement = state.options.placement;
                state.orderedModifiers.forEach(function(modifier) {
                    return state.modifiersData[modifier.name] = Object.assign({
                    }, modifier.data);
                });
                var __debug_loops__ = 0;
                for(var index = 0; index < state.orderedModifiers.length; index++){
                    if (state.reset === true) {
                        state.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {
                    } : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn2 === "function") state = fn2({
                        state,
                        options: _options,
                        name,
                        instance
                    }) || state;
                }
            },
            update: debounce(function() {
                return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            }
        };
        if (!areValidElements(reference2, popper2)) return instance;
        instance.setOptions(options).then(function(state2) {
            if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state2);
        });
        function runModifierEffects() {
            state.orderedModifiers.forEach(function(_ref3) {
                var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {
                } : _ref3$options, effect4 = _ref3.effect;
                if (typeof effect4 === "function") {
                    var cleanupFn = effect4({
                        state,
                        name,
                        instance,
                        options: options2
                    });
                    var noopFn = function noopFn2() {
                    };
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn2) {
                return fn2();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
// node_modules/@popperjs/core/dist/esm/modifiers/eventListeners.js
var passive = {
    passive: true
};
function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
    });
    if (resize) window2.addEventListener("resize", instance.update, passive);
    return function() {
        if (scroll) scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
        });
        if (resize) window2.removeEventListener("resize", instance.update, passive);
    };
}
var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {
    }
};
// node_modules/@popperjs/core/dist/esm/modifiers/popperOffsets.js
function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
    });
}
var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {
    }
};
// node_modules/@popperjs/core/dist/esm/modifiers/computeStyles.js
var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
    };
}
function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x,
        y
    }) : {
        x,
        y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
            offsetParent = getDocumentElement(popper2);
            if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
                heightProp = "scrollHeight";
                widthProp = "scrollWidth";
            }
        }
        if (placement === top || (placement === left || placement === right) && variation === end) {
            sideY = bottom;
            var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
            sideX = right;
            var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign({
        position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x,
        y
    }) : {
        x,
        y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({
        }, commonStyles, (_Object$assign = {
        }, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({
    }, commonStyles, (_Object$assign2 = {
    }, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var transitionProperty, property;
    var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({
    }, state.styles.popper, mapToStyles(Object.assign({
    }, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
    })));
    if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({
    }, state.styles.arrow, mapToStyles(Object.assign({
    }, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
    })));
    state.attributes.popper = Object.assign({
    }, state.attributes.popper, {
        "data-popper-placement": state.placement
    });
}
var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {
    }
};
// node_modules/@popperjs/core/dist/esm/modifiers/applyStyles.js
function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {
        };
        var attributes = state.attributes[name] || {
        };
        var element = state.elements[name];
        if (!isHTMLElement(element) || !getNodeName(element)) return;
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name2) {
            var value = attributes[name2];
            if (value === false) element.removeAttribute(name2);
            else element.setAttribute(name2, value === true ? "" : value);
        });
    });
}
function effect2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {
        }
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
    return function() {
        Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {
            };
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
            var style = styleProperties.reduce(function(style2, property) {
                style2[property] = "";
                return style2;
            }, {
            });
            if (!isHTMLElement(element) || !getNodeName(element)) return;
            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function(attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
}
var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect2,
    requires: [
        "computeStyles"
    ]
};
// node_modules/@popperjs/core/dist/esm/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [
        left,
        top
    ].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({
    }, rects, {
        placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [
        left,
        right
    ].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
    } : {
        x: skidding,
        y: distance
    };
}
function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [
        0,
        0
    ] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
    }, {
    });
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
}
var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: [
        "popperOffsets"
    ],
    fn: offset
};
// node_modules/@popperjs/core/dist/esm/utils/getOppositePlacement.js
var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
    });
}
// node_modules/@popperjs/core/dist/esm/utils/getOppositeVariationPlacement.js
var hash2 = {
    start: "end",
    end: "start"
};
function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
        return hash2[matched];
    });
}
// node_modules/@popperjs/core/dist/esm/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
    if (options === void 0) options = {
    };
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) allowedPlacements = placements2;
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding
        })[getBasePlacement(placement2)];
        return acc;
    }, {
    });
    return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
    });
}
// node_modules/@popperjs/core/dist/esm/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) return [];
    var oppositePlacement = getOppositePlacement(placement);
    return [
        getOppositeVariationPlacement(placement),
        oppositePlacement,
        getOppositeVariationPlacement(oppositePlacement)
    ];
}
function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) return;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
        getOppositePlacement(preferredPlacement)
    ] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [
        preferredPlacement
    ].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding,
            flipVariations,
            allowedAutoPlacements
        }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for(var i = 0; i < placements2.length; i++){
        var placement = placements2[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [
            top,
            bottom
        ].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
            placement,
            boundary,
            rootBoundary,
            altBoundary,
            padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) mainVariationSide = getOppositePlacement(mainVariationSide);
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
        if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        if (checks.every(function(check) {
            return check;
        })) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
            var fittingPlacement = placements2.find(function(placement2) {
                var checks2 = checksMap.get(placement2);
                if (checks2) return checks2.slice(0, _i2).every(function(check) {
                    return check;
                });
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for(var _i = numberOfChecks; _i > 0; _i--){
            var _ret = _loop(_i);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
}
var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: [
        "offset"
    ],
    data: {
        _skip: false
    }
};
// node_modules/@popperjs/core/dist/esm/utils/getAltAxis.js
function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
}
// node_modules/@popperjs/core/dist/esm/utils/within.js
function within(min2, value, max2) {
    return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
}
// node_modules/@popperjs/core/dist/esm/modifiers/preventOverflow.js
function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({
    }, state.rects, {
        placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
        x: 0,
        y: 0
    };
    if (!popperOffsets2) return;
    if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min2 = offset2 + overflow[mainSide];
        var max2 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
            width: 0,
            height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [
            top,
            left
        ].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
}
var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: [
        "offset"
    ]
};
// node_modules/@popperjs/core/dist/esm/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({
    }, state.rects, {
        placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [
        left,
        right
    ].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) return;
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {
    }, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect3(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) return;
    if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) return;
    }
    if (!contains(state.elements.popper, arrowElement)) return;
    state.elements.arrow = arrowElement;
}
var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect3,
    requires: [
        "popperOffsets"
    ],
    requiresIfExists: [
        "preventOverflow"
    ]
};
// node_modules/@popperjs/core/dist/esm/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) preventedOffsets = {
        x: 0,
        y: 0
    };
    return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
    };
}
function isAnySideFullyClipped(overflow) {
    return [
        top,
        right,
        bottom,
        left
    ].some(function(side) {
        return overflow[side] >= 0;
    });
}
function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
        elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
    };
    state.attributes.popper = Object.assign({
    }, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
    });
}
var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: [
        "preventOverflow"
    ],
    fn: hide
};
// node_modules/@popperjs/core/dist/esm/popper.js
var defaultModifiers = [
    eventListeners_default,
    popperOffsets_default,
    computeStyles_default,
    applyStyles_default,
    offset_default,
    flip_default,
    preventOverflow_default,
    arrow_default,
    hide_default
];
var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4qLvQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_chunkJEOVVW2QJs.SlSwitch
);
var _chunkJEOVVW2QJs = require("../../chunks/chunk.JEOVVW2Q.js");
var _chunkMC6A6AKPJs = require("../../chunks/chunk.MC6A6AKP.js");
var _chunkGPPFFSGRJs = require("../../chunks/chunk.GPPFFSGR.js");
var _chunk4654KI5LJs = require("../../chunks/chunk.4654KI5L.js");
var _chunkW2WMQSCEJs = require("../../chunks/chunk.W2WMQSCE.js");
var _chunkAN2XMPAVJs = require("../../chunks/chunk.AN2XMPAV.js");
var _chunkKJOCH52QJs = require("../../chunks/chunk.KJOCH52Q.js");
var _chunk2JQPDYNAJs = require("../../chunks/chunk.2JQPDYNA.js");
var _chunkBD26TKS4Js = require("../../chunks/chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("../../chunks/chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("../../chunks/chunk.5PPINAFI.js");
var _chunkFGQFMRZUJs = require("../../chunks/chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("../../chunks/chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("../../chunks/chunk.4M3HOXYQ.js");

},{"../../chunks/chunk.JEOVVW2Q.js":"keFBh","../../chunks/chunk.MC6A6AKP.js":"hqIGK","../../chunks/chunk.GPPFFSGR.js":"cl2mB","../../chunks/chunk.4654KI5L.js":"3AQaY","../../chunks/chunk.W2WMQSCE.js":"9o2tn","../../chunks/chunk.AN2XMPAV.js":"2bW2A","../../chunks/chunk.KJOCH52Q.js":"e6TXF","../../chunks/chunk.2JQPDYNA.js":"4Ri6Y","../../chunks/chunk.BD26TKS4.js":"1j2NX","../../chunks/chunk.I4TE3TJV.js":"i4CGq","../../chunks/chunk.5PPINAFI.js":"a2lYY","../../chunks/chunk.FGQFMRZU.js":"9cs7U","../../chunks/chunk.2VBMOEKG.js":"jJ4XN","../../chunks/chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"keFBh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlSwitch", ()=>SlSwitch
);
var _chunkMC6A6AKPJs = require("./chunk.MC6A6AKP.js");
var _chunkGPPFFSGRJs = require("./chunk.GPPFFSGR.js");
var _chunk4654KI5LJs = require("./chunk.4654KI5L.js");
var _chunkW2WMQSCEJs = require("./chunk.W2WMQSCE.js");
var _chunkKJOCH52QJs = require("./chunk.KJOCH52Q.js");
var _chunkBD26TKS4Js = require("./chunk.BD26TKS4.js");
var _chunkI4TE3TJVJs = require("./chunk.I4TE3TJV.js");
var _chunk5PPINAFIJs = require("./chunk.5PPINAFI.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
var _chunk4M3HOXYQJs = require("./chunk.4M3HOXYQ.js");
// src/components/switch/switch.ts
var id = 0;
var SlSwitch = class extends _chunk2VBMOEKGJs.s {
    constructor(){
        super(...arguments);
        this.formSubmitController = new _chunk4654KI5LJs.FormSubmitController(this, {
            value: (control)=>control.checked ? control.value : void 0
        });
        this.switchId = `switch-${++id}`;
        this.labelId = `switch-label-${id}`;
        this.hasFocus = false;
        this.disabled = false;
        this.required = false;
        this.checked = false;
        this.invalid = false;
    }
    firstUpdated() {
        this.invalid = !this.input.checkValidity();
    }
    click() {
        this.input.click();
    }
    focus(options) {
        this.input.focus(options);
    }
    blur() {
        this.input.blur();
    }
    reportValidity() {
        return this.input.reportValidity();
    }
    setCustomValidity(message) {
        this.input.setCustomValidity(message);
        this.invalid = !this.input.checkValidity();
    }
    handleBlur() {
        this.hasFocus = false;
        _chunkI4TE3TJVJs.emit(this, "sl-blur");
    }
    handleCheckedChange() {
        if (this.input) {
            this.input.checked = this.checked;
            this.invalid = !this.input.checkValidity();
        }
    }
    handleClick() {
        this.checked = !this.checked;
        _chunkI4TE3TJVJs.emit(this, "sl-change");
    }
    handleDisabledChange() {
        if (this.input) {
            this.input.disabled = this.disabled;
            this.invalid = !this.input.checkValidity();
        }
    }
    handleFocus() {
        this.hasFocus = true;
        _chunkI4TE3TJVJs.emit(this, "sl-focus");
    }
    handleKeyDown(event) {
        if (event.key === "ArrowLeft") {
            event.preventDefault();
            this.checked = false;
            _chunkI4TE3TJVJs.emit(this, "sl-change");
        }
        if (event.key === "ArrowRight") {
            event.preventDefault();
            this.checked = true;
            _chunkI4TE3TJVJs.emit(this, "sl-change");
        }
    }
    render() {
        return _chunk2VBMOEKGJs.$`
      <label
        part="base"
        for=${this.switchId}
        class=${_chunkW2WMQSCEJs.o({
            switch: true,
            "switch--checked": this.checked,
            "switch--disabled": this.disabled,
            "switch--focused": this.hasFocus
        })}
      >
        <input
          id=${this.switchId}
          class="switch__input"
          type="checkbox"
          name=${_chunkKJOCH52QJs.l(this.name)}
          value=${_chunkKJOCH52QJs.l(this.value)}
          .checked=${_chunkGPPFFSGRJs.l(this.checked)}
          .disabled=${this.disabled}
          .required=${this.required}
          role="switch"
          aria-checked=${this.checked ? "true" : "false"}
          aria-labelledby=${this.labelId}
          @click=${this.handleClick}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @keydown=${this.handleKeyDown}
        />

        <span part="control" class="switch__control">
          <span part="thumb" class="switch__thumb"></span>
        </span>

        <span part="label" id=${this.labelId} class="switch__label">
          <slot></slot>
        </span>
      </label>
    `;
    }
};
SlSwitch.styles = _chunkMC6A6AKPJs.switch_styles_default;
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.i('input[type="checkbox"]')
], SlSwitch.prototype, "input", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.t()
], SlSwitch.prototype, "hasFocus", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlSwitch.prototype, "name", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e()
], SlSwitch.prototype, "value", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlSwitch.prototype, "disabled", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlSwitch.prototype, "required", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlSwitch.prototype, "checked", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.e({
        type: Boolean,
        reflect: true
    })
], SlSwitch.prototype, "invalid", 2);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("checked")
], SlSwitch.prototype, "handleCheckedChange", 1);
_chunk4M3HOXYQJs.__decorateClass([
    _chunkBD26TKS4Js.watch("disabled")
], SlSwitch.prototype, "handleDisabledChange", 1);
SlSwitch = _chunk4M3HOXYQJs.__decorateClass([
    _chunk5PPINAFIJs.n("sl-switch")
], SlSwitch);

},{"./chunk.MC6A6AKP.js":"hqIGK","./chunk.GPPFFSGR.js":"cl2mB","./chunk.4654KI5L.js":"3AQaY","./chunk.W2WMQSCE.js":"9o2tn","./chunk.KJOCH52Q.js":"e6TXF","./chunk.BD26TKS4.js":"1j2NX","./chunk.I4TE3TJV.js":"i4CGq","./chunk.5PPINAFI.js":"a2lYY","./chunk.2VBMOEKG.js":"jJ4XN","./chunk.4M3HOXYQ.js":"BRuiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hqIGK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "switch_styles_default", ()=>switch_styles_default
);
var _chunkAN2XMPAVJs = require("./chunk.AN2XMPAV.js");
var _chunkFGQFMRZUJs = require("./chunk.FGQFMRZU.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// src/components/switch/switch.styles.ts
var switch_styles_default = _chunk2VBMOEKGJs.r`
  ${_chunkFGQFMRZUJs.component_styles_default}

  :host {
    --height: var(--sl-toggle-size);
    --thumb-size: calc(var(--sl-toggle-size) + 4px);
    --width: calc(var(--height) * 2);

    display: inline-block;
  }

  .switch {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition: var(--sl-transition-fast) border-color, var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    transform: translateX(calc((var(--width) - var(--height)) / -2));
    transition: var(--sl-transition-fast) transform ease, var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color, var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input${_chunkAN2XMPAVJs.focusVisibleSelector} ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled)
    .switch__input${_chunkAN2XMPAVJs.focusVisibleSelector}
    ~ .switch__control
    .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    box-shadow: var(--sl-focus-ring);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    transform: translateX(calc((var(--width) - var(--height)) / 2));
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input${_chunkAN2XMPAVJs.focusVisibleSelector} ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled)
    .switch__input${_chunkAN2XMPAVJs.focusVisibleSelector}
    ~ .switch__control
    .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    box-shadow: var(--sl-focus-ring);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    line-height: var(--height);
    margin-left: 0.5em;
    user-select: none;
  }
`;

},{"./chunk.AN2XMPAV.js":"2bW2A","./chunk.FGQFMRZU.js":"9cs7U","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cl2mB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "l", ()=>l
) /**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
var _chunk2JQPDYNAJs = require("./chunk.2JQPDYNA.js");
var _chunk2VBMOEKGJs = require("./chunk.2VBMOEKG.js");
// node_modules/lit-html/directive-helpers.js
var r = (o)=>o.strings === void 0
;
var f = {
};
var s = (o, i2 = f)=>o._$AH = i2
;
// node_modules/lit-html/directives/live.js
var l = _chunk2JQPDYNAJs.e(class extends _chunk2JQPDYNAJs.i {
    constructor(r2){
        if (super(r2), r2.type !== _chunk2JQPDYNAJs.t.PROPERTY && r2.type !== _chunk2JQPDYNAJs.t.ATTRIBUTE && r2.type !== _chunk2JQPDYNAJs.t.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
        if (!r(r2)) throw Error("`live` bindings can only contain a single expression");
    }
    render(r2) {
        return r2;
    }
    update(i2, [t2]) {
        if (t2 === _chunk2VBMOEKGJs.b || t2 === _chunk2VBMOEKGJs.w) return t2;
        const o = i2.element, l2 = i2.name;
        if (i2.type === _chunk2JQPDYNAJs.t.PROPERTY) {
            if (t2 === o[l2]) return _chunk2VBMOEKGJs.b;
        } else if (i2.type === _chunk2JQPDYNAJs.t.BOOLEAN_ATTRIBUTE) {
            if (!!t2 === o.hasAttribute(l2)) return _chunk2VBMOEKGJs.b;
        } else if (i2.type === _chunk2JQPDYNAJs.t.ATTRIBUTE && o.getAttribute(l2) === t2 + "") return _chunk2VBMOEKGJs.b;
        return s(i2), t2;
    }
});

},{"./chunk.2JQPDYNA.js":"4Ri6Y","./chunk.2VBMOEKG.js":"jJ4XN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["2iWhf","b6HaR"], "b6HaR", "parcelRequire6566")

</script>
            
        <!-------------------End of Shoelace Components Import----------------------->
        <!----Splide Importing----->
            <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"5u3zE":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "561bf5d58b610ca4";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"14Tjh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _splide = require("@splidejs/splide");
var _splideDefault = parcelHelpers.interopDefault(_splide);
var _splideMinCss = require("@splidejs/splide/dist/css/splide.min.css");

},{"@splidejs/splide":"5CJev","@splidejs/splide/dist/css/splide.min.css":"1SEZe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5CJev":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CLASSES", ()=>CLASSES
);
parcelHelpers.export(exports, "CLASS_ACTIVE", ()=>CLASS_ACTIVE
);
parcelHelpers.export(exports, "CLASS_ARROW", ()=>CLASS_ARROW
);
parcelHelpers.export(exports, "CLASS_ARROWS", ()=>CLASS_ARROWS
);
parcelHelpers.export(exports, "CLASS_ARROW_NEXT", ()=>CLASS_ARROW_NEXT
);
parcelHelpers.export(exports, "CLASS_ARROW_PREV", ()=>CLASS_ARROW_PREV
);
parcelHelpers.export(exports, "CLASS_AUTOPLAY", ()=>CLASS_AUTOPLAY
);
parcelHelpers.export(exports, "CLASS_CLONE", ()=>CLASS_CLONE
);
parcelHelpers.export(exports, "CLASS_CONTAINER", ()=>CLASS_CONTAINER
);
parcelHelpers.export(exports, "CLASS_INITIALIZED", ()=>CLASS_INITIALIZED
);
parcelHelpers.export(exports, "CLASS_LIST", ()=>CLASS_LIST
);
parcelHelpers.export(exports, "CLASS_LOADING", ()=>CLASS_LOADING
);
parcelHelpers.export(exports, "CLASS_NEXT", ()=>CLASS_NEXT
);
parcelHelpers.export(exports, "CLASS_PAGINATION", ()=>CLASS_PAGINATION
);
parcelHelpers.export(exports, "CLASS_PAGINATION_PAGE", ()=>CLASS_PAGINATION_PAGE
);
parcelHelpers.export(exports, "CLASS_PAUSE", ()=>CLASS_PAUSE
);
parcelHelpers.export(exports, "CLASS_PLAY", ()=>CLASS_PLAY
);
parcelHelpers.export(exports, "CLASS_PREV", ()=>CLASS_PREV
);
parcelHelpers.export(exports, "CLASS_PROGRESS", ()=>CLASS_PROGRESS
);
parcelHelpers.export(exports, "CLASS_PROGRESS_BAR", ()=>CLASS_PROGRESS_BAR
);
parcelHelpers.export(exports, "CLASS_ROOT", ()=>CLASS_ROOT
);
parcelHelpers.export(exports, "CLASS_SLIDE", ()=>CLASS_SLIDE
);
parcelHelpers.export(exports, "CLASS_SLIDER", ()=>CLASS_SLIDER
);
parcelHelpers.export(exports, "CLASS_SPINNER", ()=>CLASS_SPINNER
);
parcelHelpers.export(exports, "CLASS_TRACK", ()=>CLASS_TRACK
);
parcelHelpers.export(exports, "CLASS_VISIBLE", ()=>CLASS_VISIBLE
);
parcelHelpers.export(exports, "EVENT_ACTIVE", ()=>EVENT_ACTIVE
);
parcelHelpers.export(exports, "EVENT_ARROWS_MOUNTED", ()=>EVENT_ARROWS_MOUNTED
);
parcelHelpers.export(exports, "EVENT_ARROWS_UPDATED", ()=>EVENT_ARROWS_UPDATED
);
parcelHelpers.export(exports, "EVENT_AUTOPLAY_PAUSE", ()=>EVENT_AUTOPLAY_PAUSE
);
parcelHelpers.export(exports, "EVENT_AUTOPLAY_PLAY", ()=>EVENT_AUTOPLAY_PLAY
);
parcelHelpers.export(exports, "EVENT_AUTOPLAY_PLAYING", ()=>EVENT_AUTOPLAY_PLAYING
);
parcelHelpers.export(exports, "EVENT_CLICK", ()=>EVENT_CLICK
);
parcelHelpers.export(exports, "EVENT_DESTROY", ()=>EVENT_DESTROY
);
parcelHelpers.export(exports, "EVENT_DRAG", ()=>EVENT_DRAG
);
parcelHelpers.export(exports, "EVENT_DRAGGED", ()=>EVENT_DRAGGED
);
parcelHelpers.export(exports, "EVENT_DRAGGING", ()=>EVENT_DRAGGING
);
parcelHelpers.export(exports, "EVENT_HIDDEN", ()=>EVENT_HIDDEN
);
parcelHelpers.export(exports, "EVENT_INACTIVE", ()=>EVENT_INACTIVE
);
parcelHelpers.export(exports, "EVENT_LAZYLOAD_LOADED", ()=>EVENT_LAZYLOAD_LOADED
);
parcelHelpers.export(exports, "EVENT_MOUNTED", ()=>EVENT_MOUNTED
);
parcelHelpers.export(exports, "EVENT_MOVE", ()=>EVENT_MOVE
);
parcelHelpers.export(exports, "EVENT_MOVED", ()=>EVENT_MOVED
);
parcelHelpers.export(exports, "EVENT_NAVIGATION_MOUNTED", ()=>EVENT_NAVIGATION_MOUNTED
);
parcelHelpers.export(exports, "EVENT_PAGINATION_MOUNTED", ()=>EVENT_PAGINATION_MOUNTED
);
parcelHelpers.export(exports, "EVENT_PAGINATION_UPDATED", ()=>EVENT_PAGINATION_UPDATED
);
parcelHelpers.export(exports, "EVENT_READY", ()=>EVENT_READY
);
parcelHelpers.export(exports, "EVENT_REFRESH", ()=>EVENT_REFRESH
);
parcelHelpers.export(exports, "EVENT_REPOSITIONED", ()=>EVENT_REPOSITIONED
);
parcelHelpers.export(exports, "EVENT_RESIZE", ()=>EVENT_RESIZE
);
parcelHelpers.export(exports, "EVENT_RESIZED", ()=>EVENT_RESIZED
);
parcelHelpers.export(exports, "EVENT_SCROLL", ()=>EVENT_SCROLL
);
parcelHelpers.export(exports, "EVENT_SCROLLED", ()=>EVENT_SCROLLED
);
parcelHelpers.export(exports, "EVENT_SHIFTED", ()=>EVENT_SHIFTED
);
parcelHelpers.export(exports, "EVENT_SLIDE_KEYDOWN", ()=>EVENT_SLIDE_KEYDOWN
);
parcelHelpers.export(exports, "EVENT_UPDATED", ()=>EVENT_UPDATED
);
parcelHelpers.export(exports, "EVENT_VISIBLE", ()=>EVENT_VISIBLE
);
parcelHelpers.export(exports, "EventBus", ()=>EventBus
);
parcelHelpers.export(exports, "EventInterface", ()=>EventInterface
);
parcelHelpers.export(exports, "RequestInterval", ()=>RequestInterval
);
parcelHelpers.export(exports, "STATUS_CLASSES", ()=>STATUS_CLASSES
);
parcelHelpers.export(exports, "Splide", ()=>Splide
);
parcelHelpers.export(exports, "SplideRenderer", ()=>SplideRenderer
);
parcelHelpers.export(exports, "State", ()=>State
);
parcelHelpers.export(exports, "Throttle", ()=>Throttle
);
parcelHelpers.export(exports, "default", ()=>Splide
);
/*!
 * Splide.js
 * Version  : 3.6.9
 * License  : MIT
 * Copyright: 2021 Naotoshi Fujita
 */ const PROJECT_CODE = "splide";
const DATA_ATTRIBUTE = `data-${PROJECT_CODE}`;
const CREATED = 1;
const MOUNTED = 2;
const IDLE = 3;
const MOVING = 4;
const DESTROYED = 5;
const STATES = {
    CREATED,
    MOUNTED,
    IDLE,
    MOVING,
    DESTROYED
};
const DEFAULT_EVENT_PRIORITY = 10;
const DEFAULT_USER_EVENT_PRIORITY = 20;
function empty(array) {
    array.length = 0;
}
function isObject(subject) {
    return !isNull(subject) && typeof subject === "object";
}
function isArray(subject) {
    return Array.isArray(subject);
}
function isFunction(subject) {
    return typeof subject === "function";
}
function isString(subject) {
    return typeof subject === "string";
}
function isUndefined(subject) {
    return typeof subject === "undefined";
}
function isNull(subject) {
    return subject === null;
}
function isHTMLElement(subject) {
    return subject instanceof HTMLElement;
}
function toArray(value) {
    return isArray(value) ? value : [
        value
    ];
}
function forEach(values, iteratee) {
    toArray(values).forEach(iteratee);
}
function includes(array, value) {
    return array.indexOf(value) > -1;
}
function push(array, items) {
    array.push(...toArray(items));
    return array;
}
const arrayProto = Array.prototype;
function slice(arrayLike, start, end) {
    return arrayProto.slice.call(arrayLike, start, end);
}
function find(arrayLike, predicate) {
    return slice(arrayLike).filter(predicate)[0];
}
function toggleClass(elm, classes, add) {
    if (elm) forEach(classes, (name)=>{
        if (name) elm.classList[add ? "add" : "remove"](name);
    });
}
function addClass(elm, classes) {
    toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
}
function append(parent, children1) {
    forEach(children1, parent.appendChild.bind(parent));
}
function before(nodes, ref) {
    forEach(nodes, (node)=>{
        const parent = ref.parentNode;
        if (parent) parent.insertBefore(node, ref);
    });
}
function matches(elm, selector) {
    return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
}
function children(parent, selector) {
    return parent ? slice(parent.children).filter((child1)=>matches(child1, selector)
    ) : [];
}
function child(parent, selector) {
    return selector ? children(parent, selector)[0] : parent.firstElementChild;
}
function forOwn(object, iteratee, right) {
    if (object) {
        let keys = Object.keys(object);
        keys = right ? keys.reverse() : keys;
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            if (key !== "__proto__") {
                if (iteratee(object[key], key) === false) break;
            }
        }
    }
    return object;
}
function assign(object) {
    slice(arguments, 1).forEach((source)=>{
        forOwn(source, (value, key)=>{
            object[key] = source[key];
        });
    });
    return object;
}
function merge(object, source) {
    forOwn(source, (value, key)=>{
        if (isArray(value)) object[key] = value.slice();
        else if (isObject(value)) object[key] = merge(isObject(object[key]) ? object[key] : {
        }, value);
        else object[key] = value;
    });
    return object;
}
function removeAttribute(elm, attrs) {
    if (elm) forEach(attrs, (attr)=>{
        elm.removeAttribute(attr);
    });
}
function setAttribute(elm, attrs, value) {
    if (isObject(attrs)) forOwn(attrs, (value2, name)=>{
        setAttribute(elm, name, value2);
    });
    else isNull(value) ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
}
function create(tag, attrs, parent) {
    const elm = document.createElement(tag);
    if (attrs) isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
    parent && append(parent, elm);
    return elm;
}
function style(elm, prop, value) {
    if (isUndefined(value)) return getComputedStyle(elm)[prop];
    if (!isNull(value)) {
        const { style: style2  } = elm;
        value = `${value}`;
        if (style2[prop] !== value) style2[prop] = value;
    }
}
function display(elm, display2) {
    style(elm, "display", display2);
}
function focus(elm) {
    elm["setActive"] && elm["setActive"]() || elm.focus({
        preventScroll: true
    });
}
function getAttribute(elm, attr) {
    return elm.getAttribute(attr);
}
function hasClass(elm, className) {
    return elm && elm.classList.contains(className);
}
function rect(target) {
    return target.getBoundingClientRect();
}
function remove(nodes) {
    forEach(nodes, (node)=>{
        if (node && node.parentNode) node.parentNode.removeChild(node);
    });
}
function measure(parent, value) {
    if (isString(value)) {
        const div = create("div", {
            style: `width: ${value}; position: absolute;`
        }, parent);
        value = rect(div).width;
        remove(div);
    }
    return value;
}
function parseHtml(html) {
    return child(new DOMParser().parseFromString(html, "text/html").body);
}
function prevent(e, stopPropagation) {
    e.preventDefault();
    if (stopPropagation) {
        e.stopPropagation();
        e.stopImmediatePropagation();
    }
}
function query(parent, selector) {
    return parent && parent.querySelector(selector);
}
function queryAll(parent, selector) {
    return slice(parent.querySelectorAll(selector));
}
function removeClass(elm, classes) {
    toggleClass(elm, classes, false);
}
function unit(value) {
    return isString(value) ? value : value ? `${value}px` : "";
}
function assert(condition, message = "") {
    if (!condition) throw new Error(`[${PROJECT_CODE}] ${message}`);
}
function nextTick(callback) {
    setTimeout(callback);
}
const noop = ()=>{
};
function raf(func) {
    return requestAnimationFrame(func);
}
const { min , max , floor , ceil , abs  } = Math;
function approximatelyEqual(x, y, epsilon) {
    return abs(x - y) < epsilon;
}
function between(number, minOrMax, maxOrMin, exclusive) {
    const minimum = min(minOrMax, maxOrMin);
    const maximum = max(minOrMax, maxOrMin);
    return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
}
function clamp(number, x, y) {
    const minimum = min(x, y);
    const maximum = max(x, y);
    return min(max(minimum, number), maximum);
}
function sign(x) {
    return +(x > 0) - +(x < 0);
}
function camelToKebab(string) {
    return string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function format(string, replacements) {
    forEach(replacements, (replacement)=>{
        string = string.replace("%s", `${replacement}`);
    });
    return string;
}
function pad(number) {
    return number < 10 ? `0${number}` : `${number}`;
}
const ids = {
};
function uniqueId(prefix) {
    return `${prefix}${pad(ids[prefix] = (ids[prefix] || 0) + 1)}`;
}
function EventBus() {
    let handlers = {
    };
    function on(events, callback, key, priority = DEFAULT_EVENT_PRIORITY) {
        forEachEvent(events, (event, namespace)=>{
            handlers[event] = handlers[event] || [];
            push(handlers[event], {
                _event: event,
                _callback: callback,
                _namespace: namespace,
                _priority: priority,
                _key: key
            }).sort((handler1, handler2)=>handler1._priority - handler2._priority
            );
        });
    }
    function off(events, key) {
        forEachEvent(events, (event, namespace)=>{
            const eventHandlers = handlers[event];
            handlers[event] = eventHandlers && eventHandlers.filter((handler)=>{
                return handler._key ? handler._key !== key : key || handler._namespace !== namespace;
            });
        });
    }
    function offBy(key) {
        forOwn(handlers, (eventHandlers, event)=>{
            off(event, key);
        });
    }
    function emit(event) {
        (handlers[event] || []).forEach((handler)=>{
            handler._callback.apply(handler, slice(arguments, 1));
        });
    }
    function destroy() {
        handlers = {
        };
    }
    function forEachEvent(events, iteratee) {
        toArray(events).join(" ").split(" ").forEach((eventNS)=>{
            const fragments = eventNS.split(".");
            iteratee(fragments[0], fragments[1]);
        });
    }
    return {
        on,
        off,
        offBy,
        emit,
        destroy
    };
}
const EVENT_MOUNTED = "mounted";
const EVENT_READY = "ready";
const EVENT_MOVE = "move";
const EVENT_MOVED = "moved";
const EVENT_SHIFTED = "shifted";
const EVENT_CLICK = "click";
const EVENT_ACTIVE = "active";
const EVENT_INACTIVE = "inactive";
const EVENT_VISIBLE = "visible";
const EVENT_HIDDEN = "hidden";
const EVENT_SLIDE_KEYDOWN = "slide:keydown";
const EVENT_REFRESH = "refresh";
const EVENT_UPDATED = "updated";
const EVENT_RESIZE = "resize";
const EVENT_RESIZED = "resized";
const EVENT_REPOSITIONED = "repositioned";
const EVENT_DRAG = "drag";
const EVENT_DRAGGING = "dragging";
const EVENT_DRAGGED = "dragged";
const EVENT_SCROLL = "scroll";
const EVENT_SCROLLED = "scrolled";
const EVENT_DESTROY = "destroy";
const EVENT_ARROWS_MOUNTED = "arrows:mounted";
const EVENT_ARROWS_UPDATED = "arrows:updated";
const EVENT_PAGINATION_MOUNTED = "pagination:mounted";
const EVENT_PAGINATION_UPDATED = "pagination:updated";
const EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
const EVENT_AUTOPLAY_PLAY = "autoplay:play";
const EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
const EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
const EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
function EventInterface(Splide2) {
    const { event  } = Splide2;
    const key = {
    };
    let listeners = [];
    function on(events, callback, priority) {
        event.on(events, callback, key, priority);
    }
    function off(events) {
        event.off(events, key);
    }
    function bind(targets, events, callback, options) {
        forEachEvent(targets, events, (target, event2)=>{
            listeners.push([
                target,
                event2,
                callback,
                options
            ]);
            target.addEventListener(event2, callback, options);
        });
    }
    function unbind(targets, events, callback) {
        forEachEvent(targets, events, (target, event2)=>{
            listeners = listeners.filter((listener)=>{
                if (listener[0] === target && listener[1] === event2 && (!callback || listener[2] === callback)) {
                    target.removeEventListener(event2, listener[2], listener[3]);
                    return false;
                }
                return true;
            });
        });
    }
    function forEachEvent(targets, events, iteratee) {
        forEach(targets, (target)=>{
            if (target) events.split(" ").forEach(iteratee.bind(null, target));
        });
    }
    function destroy() {
        listeners = listeners.filter((data)=>unbind(data[0], data[1])
        );
        event.offBy(key);
    }
    event.on(EVENT_DESTROY, destroy, key);
    return {
        on,
        off,
        emit: event.emit,
        bind,
        unbind,
        destroy
    };
}
function RequestInterval(interval, onInterval, onUpdate, limit) {
    const { now  } = Date;
    let startTime;
    let rate = 0;
    let id;
    let paused = true;
    let count = 0;
    function update() {
        if (!paused) {
            const elapsed = now() - startTime;
            if (elapsed >= interval) {
                rate = 1;
                startTime = now();
            } else rate = elapsed / interval;
            if (onUpdate) onUpdate(rate);
            if (rate === 1) {
                onInterval();
                if (limit && ++count >= limit) return pause();
            }
            raf(update);
        }
    }
    function start(resume) {
        !resume && cancel();
        startTime = now() - (resume ? rate * interval : 0);
        paused = false;
        raf(update);
    }
    function pause() {
        paused = true;
    }
    function rewind() {
        startTime = now();
        rate = 0;
        if (onUpdate) onUpdate(rate);
    }
    function cancel() {
        cancelAnimationFrame(id);
        rate = 0;
        id = 0;
        paused = true;
    }
    function set(time) {
        interval = time;
    }
    function isPaused() {
        return paused;
    }
    return {
        start,
        rewind,
        pause,
        cancel,
        set,
        isPaused
    };
}
function State(initialState) {
    let state = initialState;
    function set(value) {
        state = value;
    }
    function is(states) {
        return includes(toArray(states), state);
    }
    return {
        set,
        is
    };
}
function Throttle(func, duration) {
    let interval;
    function throttled() {
        if (!interval) {
            interval = RequestInterval(duration || 0, ()=>{
                func.apply(this, arguments);
                interval = null;
            }, null, 1);
            interval.start();
        }
    }
    return throttled;
}
function Options(Splide2, Components2, options) {
    const throttledObserve = Throttle(observe);
    let initialOptions;
    let points;
    let currPoint;
    function setup() {
        try {
            merge(options, JSON.parse(getAttribute(Splide2.root, DATA_ATTRIBUTE)));
        } catch (e) {
            assert(false, e.message);
        }
        initialOptions = merge({
        }, options);
        const { breakpoints  } = options;
        if (breakpoints) {
            const isMin = options.mediaQuery === "min";
            points = Object.keys(breakpoints).sort((n, m)=>isMin ? +m - +n : +n - +m
            ).map((point)=>[
                    point,
                    matchMedia(`(${isMin ? "min" : "max"}-width:${point}px)`)
                ]
            );
            observe();
        }
    }
    function mount() {
        if (points) addEventListener("resize", throttledObserve);
    }
    function destroy(completely) {
        if (completely) removeEventListener("resize", throttledObserve);
    }
    function observe() {
        const item = find(points, (item2)=>item2[1].matches
        ) || [];
        if (item[0] !== currPoint) onMatch(currPoint = item[0]);
    }
    function onMatch(point) {
        const newOptions = options.breakpoints[point] || initialOptions;
        if (newOptions.destroy) {
            Splide2.options = initialOptions;
            Splide2.destroy(newOptions.destroy === "completely");
        } else {
            if (Splide2.state.is(DESTROYED)) {
                destroy(true);
                Splide2.mount();
            }
            Splide2.options = newOptions;
        }
    }
    return {
        setup,
        mount,
        destroy
    };
}
const RTL = "rtl";
const TTB = "ttb";
const ORIENTATION_MAP = {
    marginRight: [
        "marginBottom",
        "marginLeft"
    ],
    autoWidth: [
        "autoHeight"
    ],
    fixedWidth: [
        "fixedHeight"
    ],
    paddingLeft: [
        "paddingTop",
        "paddingRight"
    ],
    paddingRight: [
        "paddingBottom",
        "paddingLeft"
    ],
    width: [
        "height"
    ],
    left: [
        "top",
        "right"
    ],
    right: [
        "bottom",
        "left"
    ],
    x: [
        "y"
    ],
    X: [
        "Y"
    ],
    Y: [
        "X"
    ],
    ArrowLeft: [
        "ArrowUp",
        "ArrowRight"
    ],
    ArrowRight: [
        "ArrowDown",
        "ArrowLeft"
    ]
};
function Direction(Splide2, Components2, options) {
    function resolve(prop, axisOnly) {
        const { direction  } = options;
        const index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
        return ORIENTATION_MAP[prop][index] || prop;
    }
    function orient(value) {
        return value * (options.direction === RTL ? 1 : -1);
    }
    return {
        resolve,
        orient
    };
}
const CLASS_ROOT = PROJECT_CODE;
const CLASS_SLIDER = `${PROJECT_CODE}__slider`;
const CLASS_TRACK = `${PROJECT_CODE}__track`;
const CLASS_LIST = `${PROJECT_CODE}__list`;
const CLASS_SLIDE = `${PROJECT_CODE}__slide`;
const CLASS_CLONE = `${CLASS_SLIDE}--clone`;
const CLASS_CONTAINER = `${CLASS_SLIDE}__container`;
const CLASS_ARROWS = `${PROJECT_CODE}__arrows`;
const CLASS_ARROW = `${PROJECT_CODE}__arrow`;
const CLASS_ARROW_PREV = `${CLASS_ARROW}--prev`;
const CLASS_ARROW_NEXT = `${CLASS_ARROW}--next`;
const CLASS_PAGINATION = `${PROJECT_CODE}__pagination`;
const CLASS_PAGINATION_PAGE = `${CLASS_PAGINATION}__page`;
const CLASS_PROGRESS = `${PROJECT_CODE}__progress`;
const CLASS_PROGRESS_BAR = `${CLASS_PROGRESS}__bar`;
const CLASS_AUTOPLAY = `${PROJECT_CODE}__autoplay`;
const CLASS_PLAY = `${PROJECT_CODE}__play`;
const CLASS_PAUSE = `${PROJECT_CODE}__pause`;
const CLASS_SPINNER = `${PROJECT_CODE}__spinner`;
const CLASS_INITIALIZED = "is-initialized";
const CLASS_ACTIVE = "is-active";
const CLASS_PREV = "is-prev";
const CLASS_NEXT = "is-next";
const CLASS_VISIBLE = "is-visible";
const CLASS_LOADING = "is-loading";
const STATUS_CLASSES = [
    CLASS_ACTIVE,
    CLASS_VISIBLE,
    CLASS_PREV,
    CLASS_NEXT,
    CLASS_LOADING
];
const CLASSES = {
    slide: CLASS_SLIDE,
    clone: CLASS_CLONE,
    arrows: CLASS_ARROWS,
    arrow: CLASS_ARROW,
    prev: CLASS_ARROW_PREV,
    next: CLASS_ARROW_NEXT,
    pagination: CLASS_PAGINATION,
    page: CLASS_PAGINATION_PAGE,
    spinner: CLASS_SPINNER
};
function Elements(Splide2, Components2, options) {
    const { on  } = EventInterface(Splide2);
    const { root  } = Splide2;
    const elements = {
    };
    const slides = [];
    let classes;
    let slider;
    let track;
    let list;
    function setup() {
        collect();
        identify();
        addClass(root, classes = getClasses());
    }
    function mount() {
        on(EVENT_REFRESH, refresh, DEFAULT_EVENT_PRIORITY - 2);
        on(EVENT_UPDATED, update);
    }
    function destroy() {
        [
            root,
            track,
            list
        ].forEach((elm)=>{
            removeAttribute(elm, "style");
        });
        empty(slides);
        removeClass(root, classes);
    }
    function refresh() {
        destroy();
        setup();
    }
    function update() {
        removeClass(root, classes);
        addClass(root, classes = getClasses());
    }
    function collect() {
        slider = child(root, `.${CLASS_SLIDER}`);
        track = query(root, `.${CLASS_TRACK}`);
        list = child(track, `.${CLASS_LIST}`);
        assert(track && list, "A track/list element is missing.");
        push(slides, children(list, `.${CLASS_SLIDE}:not(.${CLASS_CLONE})`));
        const autoplay = find1(`.${CLASS_AUTOPLAY}`);
        const arrows = find1(`.${CLASS_ARROWS}`);
        assign(elements, {
            root,
            slider,
            track,
            list,
            slides,
            arrows,
            autoplay,
            prev: query(arrows, `.${CLASS_ARROW_PREV}`),
            next: query(arrows, `.${CLASS_ARROW_NEXT}`),
            bar: query(find1(`.${CLASS_PROGRESS}`), `.${CLASS_PROGRESS_BAR}`),
            play: query(autoplay, `.${CLASS_PLAY}`),
            pause: query(autoplay, `.${CLASS_PAUSE}`)
        });
    }
    function identify() {
        const id = root.id || uniqueId(PROJECT_CODE);
        root.id = id;
        track.id = track.id || `${id}-track`;
        list.id = list.id || `${id}-list`;
    }
    function find1(selector) {
        return child(root, selector) || child(slider, selector);
    }
    function getClasses() {
        return [
            `${CLASS_ROOT}--${options.type}`,
            `${CLASS_ROOT}--${options.direction}`,
            options.drag && `${CLASS_ROOT}--draggable`,
            options.isNavigation && `${CLASS_ROOT}--nav`,
            CLASS_ACTIVE
        ];
    }
    return assign(elements, {
        setup,
        mount,
        destroy
    });
}
const ROLE = "role";
const ARIA_CONTROLS = "aria-controls";
const ARIA_CURRENT = "aria-current";
const ARIA_LABEL = "aria-label";
const ARIA_HIDDEN = "aria-hidden";
const TAB_INDEX = "tabindex";
const DISABLED = "disabled";
const ARIA_ORIENTATION = "aria-orientation";
const ALL_ATTRIBUTES = [
    ROLE,
    ARIA_CONTROLS,
    ARIA_CURRENT,
    ARIA_LABEL,
    ARIA_HIDDEN,
    ARIA_ORIENTATION,
    TAB_INDEX,
    DISABLED
];
const SLIDE = "slide";
const LOOP = "loop";
const FADE = "fade";
function Slide$1(Splide2, index, slideIndex, slide) {
    const { on , emit , bind , destroy: destroyEvents  } = EventInterface(Splide2);
    const { Components , root , options  } = Splide2;
    const { isNavigation , updateOnMove  } = options;
    const { resolve  } = Components.Direction;
    const styles = getAttribute(slide, "style");
    const isClone = slideIndex > -1;
    const container = child(slide, `.${CLASS_CONTAINER}`);
    const focusableNodes = options.focusableNodes && queryAll(slide, options.focusableNodes);
    let destroyed;
    function mount() {
        if (!isClone) slide.id = `${root.id}-slide${pad(index + 1)}`;
        bind(slide, "click keydown", (e)=>{
            emit(e.type === "click" ? EVENT_CLICK : EVENT_SLIDE_KEYDOWN, self, e);
        });
        on([
            EVENT_REFRESH,
            EVENT_REPOSITIONED,
            EVENT_SHIFTED,
            EVENT_MOVED,
            EVENT_SCROLLED
        ], update);
        on(EVENT_NAVIGATION_MOUNTED, initNavigation);
        if (updateOnMove) on(EVENT_MOVE, onMove);
    }
    function destroy() {
        destroyed = true;
        destroyEvents();
        removeClass(slide, STATUS_CLASSES);
        removeAttribute(slide, ALL_ATTRIBUTES);
        setAttribute(slide, "style", styles);
    }
    function initNavigation() {
        const idx = isClone ? slideIndex : index;
        const label = format(options.i18n.slideX, idx + 1);
        const controls = Splide2.splides.map((target)=>target.splide.root.id
        ).join(" ");
        setAttribute(slide, ARIA_LABEL, label);
        setAttribute(slide, ARIA_CONTROLS, controls);
        setAttribute(slide, ROLE, "menuitem");
        updateActivity(isActive());
    }
    function onMove() {
        if (!destroyed) update();
    }
    function update() {
        if (!destroyed) {
            const { index: currIndex  } = Splide2;
            updateActivity(isActive());
            updateVisibility(isVisible());
            toggleClass(slide, CLASS_PREV, index === currIndex - 1);
            toggleClass(slide, CLASS_NEXT, index === currIndex + 1);
        }
    }
    function updateActivity(active) {
        if (active !== hasClass(slide, CLASS_ACTIVE)) {
            toggleClass(slide, CLASS_ACTIVE, active);
            if (isNavigation) setAttribute(slide, ARIA_CURRENT, active || null);
            emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
        }
    }
    function updateVisibility(visible) {
        const hidden = !visible && (!isActive() || isClone);
        setAttribute(slide, ARIA_HIDDEN, hidden || null);
        setAttribute(slide, TAB_INDEX, !hidden && options.slideFocus ? 0 : null);
        if (focusableNodes) focusableNodes.forEach((node)=>{
            setAttribute(node, TAB_INDEX, hidden ? -1 : null);
        });
        if (visible !== hasClass(slide, CLASS_VISIBLE)) {
            toggleClass(slide, CLASS_VISIBLE, visible);
            emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
        }
    }
    function style$1(prop, value, useContainer) {
        style(useContainer && container || slide, prop, value);
    }
    function isActive() {
        const { index: curr  } = Splide2;
        return curr === index || options.cloneStatus && curr === slideIndex;
    }
    function isVisible() {
        if (Splide2.is(FADE)) return isActive();
        const trackRect = rect(Components.Elements.track);
        const slideRect = rect(slide);
        const left = resolve("left");
        const right = resolve("right");
        return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
    }
    function isWithin(from, distance) {
        let diff = abs(from - index);
        if (!isClone && (options.rewind || Splide2.is(LOOP))) diff = min(diff, Splide2.length - diff);
        return diff <= distance;
    }
    const self = {
        index,
        slideIndex,
        slide,
        container,
        isClone,
        mount,
        destroy,
        update,
        style: style$1,
        isWithin
    };
    return self;
}
function Slides(Splide2, Components2, options) {
    const { on , emit , bind  } = EventInterface(Splide2);
    const { slides , list  } = Components2.Elements;
    const Slides2 = [];
    function mount() {
        init();
        on(EVENT_REFRESH, refresh);
        on([
            EVENT_MOUNTED,
            EVENT_REFRESH
        ], ()=>{
            Slides2.sort((Slide1, Slide2)=>Slide1.index - Slide2.index
            );
        });
    }
    function init() {
        slides.forEach((slide, index)=>{
            register(slide, index, -1);
        });
    }
    function destroy() {
        forEach$1((Slide2)=>{
            Slide2.destroy();
        });
        empty(Slides2);
    }
    function refresh() {
        destroy();
        init();
    }
    function update() {
        forEach$1((Slide2)=>{
            Slide2.update();
        });
    }
    function register(slide, index, slideIndex) {
        const object = Slide$1(Splide2, index, slideIndex, slide);
        object.mount();
        Slides2.push(object);
    }
    function get(excludeClones) {
        return excludeClones ? filter((Slide2)=>!Slide2.isClone
        ) : Slides2;
    }
    function getIn(page) {
        const { Controller: Controller1  } = Components2;
        const index = Controller1.toIndex(page);
        const max1 = Controller1.hasFocus() ? 1 : options.perPage;
        return filter((Slide2)=>between(Slide2.index, index, index + max1 - 1)
        );
    }
    function getAt(index) {
        return filter(index)[0];
    }
    function add(items, index) {
        forEach(items, (slide)=>{
            if (isString(slide)) slide = parseHtml(slide);
            if (isHTMLElement(slide)) {
                const ref = slides[index];
                ref ? before(slide, ref) : append(list, slide);
                addClass(slide, options.classes.slide);
                observeImages(slide, emit.bind(null, EVENT_RESIZE));
            }
        });
        emit(EVENT_REFRESH);
    }
    function remove$1(matcher) {
        remove(filter(matcher).map((Slide2)=>Slide2.slide
        ));
        emit(EVENT_REFRESH);
    }
    function forEach$1(iteratee, excludeClones) {
        get(excludeClones).forEach(iteratee);
    }
    function filter(matcher) {
        return Slides2.filter(isFunction(matcher) ? matcher : (Slide2)=>isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index)
        );
    }
    function style1(prop, value, useContainer) {
        forEach$1((Slide2)=>{
            Slide2.style(prop, value, useContainer);
        });
    }
    function observeImages(elm, callback) {
        const images = queryAll(elm, "img");
        let { length  } = images;
        if (length) images.forEach((img)=>{
            bind(img, "load error", ()=>{
                if (!--length) callback();
            });
        });
        else callback();
    }
    function getLength(excludeClones) {
        return excludeClones ? slides.length : Slides2.length;
    }
    function isEnough() {
        return Slides2.length > options.perPage;
    }
    return {
        mount,
        destroy,
        update,
        register,
        get,
        getIn,
        getAt,
        add,
        remove: remove$1,
        forEach: forEach$1,
        filter,
        style: style1,
        getLength,
        isEnough
    };
}
function Layout(Splide2, Components2, options) {
    const { on , bind , emit  } = EventInterface(Splide2);
    const { Slides: Slides1  } = Components2;
    const { resolve  } = Components2.Direction;
    const { root , track , list  } = Components2.Elements;
    const { getAt  } = Slides1;
    let vertical;
    let rootRect;
    function mount() {
        init();
        bind(window, "resize load", Throttle(emit.bind(this, EVENT_RESIZE)));
        on([
            EVENT_UPDATED,
            EVENT_REFRESH
        ], init);
        on(EVENT_RESIZE, resize);
    }
    function init() {
        rootRect = null;
        vertical = options.direction === TTB;
        style(root, "maxWidth", unit(options.width));
        style(track, resolve("paddingLeft"), cssPadding(false));
        style(track, resolve("paddingRight"), cssPadding(true));
        resize();
    }
    function resize() {
        const newRect = rect(root);
        if (!rootRect || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
            style(track, "height", cssTrackHeight());
            Slides1.style(resolve("marginRight"), unit(options.gap));
            Slides1.style("width", cssSlideWidth() || null);
            setSlidesHeight();
            rootRect = newRect;
            emit(EVENT_RESIZED);
        }
    }
    function setSlidesHeight() {
        Slides1.style("height", cssSlideHeight() || null, true);
    }
    function cssPadding(right) {
        const { padding  } = options;
        const prop = resolve(right ? "right" : "left");
        return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
    }
    function cssTrackHeight() {
        let height = "";
        if (vertical) {
            height = cssHeight();
            assert(height, "height or heightRatio is missing.");
            height = `calc(${height} - ${cssPadding(false)} - ${cssPadding(true)})`;
        }
        return height;
    }
    function cssHeight() {
        return unit(options.height || rect(list).width * options.heightRatio);
    }
    function cssSlideWidth() {
        return options.autoWidth ? "" : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
    }
    function cssSlideHeight() {
        return unit(options.fixedHeight) || (vertical ? options.autoHeight ? "" : cssSlideSize() : cssHeight());
    }
    function cssSlideSize() {
        const gap = unit(options.gap);
        return `calc((100%${gap && ` + ${gap}`})/${options.perPage || 1}${gap && ` - ${gap}`})`;
    }
    function listSize() {
        return rect(list)[resolve("width")];
    }
    function slideSize(index, withoutGap) {
        const Slide1 = getAt(index || 0);
        return Slide1 ? rect(Slide1.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
    }
    function totalSize(index, withoutGap) {
        const Slide2 = getAt(index);
        if (Slide2) {
            const right = rect(Slide2.slide)[resolve("right")];
            const left = rect(list)[resolve("left")];
            return abs(right - left) + (withoutGap ? 0 : getGap());
        }
        return 0;
    }
    function sliderSize() {
        return totalSize(Splide2.length - 1, true) - totalSize(-1, true);
    }
    function getGap() {
        const Slide3 = getAt(0);
        return Slide3 && parseFloat(style(Slide3.slide, resolve("marginRight"))) || 0;
    }
    function getPadding(right) {
        return parseFloat(style(track, resolve(`padding${right ? "Right" : "Left"}`))) || 0;
    }
    return {
        mount,
        listSize,
        slideSize,
        sliderSize,
        totalSize,
        getPadding
    };
}
function Clones(Splide2, Components2, options) {
    const { on , emit  } = EventInterface(Splide2);
    const { Elements: Elements1 , Slides: Slides2  } = Components2;
    const { resolve  } = Components2.Direction;
    const clones = [];
    let cloneCount;
    function mount() {
        init();
        on(EVENT_REFRESH, refresh);
        on([
            EVENT_UPDATED,
            EVENT_RESIZE
        ], observe);
    }
    function init() {
        if (cloneCount = computeCloneCount()) {
            generate(cloneCount);
            emit(EVENT_RESIZE);
        }
    }
    function destroy() {
        remove(clones);
        empty(clones);
    }
    function refresh() {
        destroy();
        init();
    }
    function observe() {
        if (cloneCount < computeCloneCount()) emit(EVENT_REFRESH);
    }
    function generate(count) {
        const slides = Slides2.get().slice();
        const { length  } = slides;
        if (length) {
            while(slides.length < count)push(slides, slides);
            push(slides.slice(-count), slides.slice(0, count)).forEach((Slide4, index)=>{
                const isHead = index < count;
                const clone = cloneDeep(Slide4.slide, index);
                isHead ? before(clone, slides[0].slide) : append(Elements1.list, clone);
                push(clones, clone);
                Slides2.register(clone, index - count + (isHead ? 0 : length), Slide4.index);
            });
        }
    }
    function cloneDeep(elm, index) {
        const clone = elm.cloneNode(true);
        addClass(clone, options.classes.clone);
        clone.id = `${Splide2.root.id}-clone${pad(index + 1)}`;
        return clone;
    }
    function computeCloneCount() {
        let { clones: clones2  } = options;
        if (!Splide2.is(LOOP)) clones2 = 0;
        else if (!clones2) {
            const fixedSize = measure(Elements1.list, options[resolve("fixedWidth")]);
            const fixedCount = fixedSize && ceil(rect(Elements1.track)[resolve("width")] / fixedSize);
            const baseCount = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage;
            clones2 = baseCount * (options.drag ? (options.flickMaxPages || 1) + 1 : 2);
        }
        return clones2;
    }
    return {
        mount,
        destroy
    };
}
function Move(Splide2, Components2, options) {
    const { on , emit  } = EventInterface(Splide2);
    const { slideSize , getPadding , totalSize , listSize , sliderSize  } = Components2.Layout;
    const { resolve , orient  } = Components2.Direction;
    const { list , track  } = Components2.Elements;
    let Transition;
    function mount() {
        Transition = Components2.Transition;
        on([
            EVENT_MOUNTED,
            EVENT_RESIZED,
            EVENT_UPDATED,
            EVENT_REFRESH
        ], reposition);
    }
    function destroy() {
        removeAttribute(list, "style");
    }
    function reposition() {
        if (!isBusy()) {
            Components2.Scroll.cancel();
            jump(Splide2.index);
            emit(EVENT_REPOSITIONED);
        }
    }
    function move(dest, index, prev, callback) {
        if (!isBusy()) {
            const { set  } = Splide2.state;
            const position = getPosition();
            if (dest !== index) {
                Transition.cancel();
                translate(shift(position, dest > index), true);
            }
            set(MOVING);
            emit(EVENT_MOVE, index, prev, dest);
            Transition.start(index, ()=>{
                set(IDLE);
                emit(EVENT_MOVED, index, prev, dest);
                if (options.trimSpace === "move" && dest !== prev && position === getPosition()) Components2.Controller.go(dest > prev ? ">" : "<", false, callback);
                else callback && callback();
            });
        }
    }
    function jump(index) {
        translate(toPosition(index, true));
    }
    function translate(position, preventLoop) {
        if (!Splide2.is(FADE)) {
            const destination = preventLoop ? position : loop(position);
            list.style.transform = `translate${resolve("X")}(${destination}px)`;
            position !== destination && emit(EVENT_SHIFTED);
        }
    }
    function loop(position) {
        if (Splide2.is(LOOP)) {
            const diff = orient(position - getPosition());
            const exceededMin = exceededLimit(false, position) && diff < 0;
            const exceededMax = exceededLimit(true, position) && diff > 0;
            if (exceededMin || exceededMax) position = shift(position, exceededMax);
        }
        return position;
    }
    function shift(position, backwards) {
        const excess = position - getLimit(backwards);
        const size = sliderSize();
        position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
        return position;
    }
    function cancel() {
        translate(getPosition());
        Transition.cancel();
    }
    function toIndex(position) {
        const Slides3 = Components2.Slides.get();
        let index = 0;
        let minDistance = Infinity;
        for(let i = 0; i < Slides3.length; i++){
            const slideIndex = Slides3[i].index;
            const distance = abs(toPosition(slideIndex, true) - position);
            if (distance <= minDistance) {
                minDistance = distance;
                index = slideIndex;
            } else break;
        }
        return index;
    }
    function toPosition(index, trimming) {
        const position = orient(totalSize(index - 1) - offset(index));
        return trimming ? trim(position) : position;
    }
    function getPosition() {
        const left = resolve("left");
        return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
    }
    function trim(position) {
        if (options.trimSpace && Splide2.is(SLIDE)) position = clamp(position, 0, orient(sliderSize() - listSize()));
        return position;
    }
    function offset(index) {
        const { focus: focus1  } = options;
        return focus1 === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus1 * slideSize(index) || 0;
    }
    function getLimit(max2) {
        return toPosition(max2 ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
    }
    function isBusy() {
        return Splide2.state.is(MOVING) && options.waitForTransition;
    }
    function exceededLimit(max3, position) {
        position = isUndefined(position) ? getPosition() : position;
        const exceededMin = max3 !== true && orient(position) < orient(getLimit(false));
        const exceededMax = max3 !== false && orient(position) > orient(getLimit(true));
        return exceededMin || exceededMax;
    }
    return {
        mount,
        destroy,
        move,
        jump,
        translate,
        shift,
        cancel,
        toIndex,
        toPosition,
        getPosition,
        getLimit,
        isBusy,
        exceededLimit
    };
}
function Controller(Splide2, Components2, options) {
    const { on  } = EventInterface(Splide2);
    const { Move: Move1  } = Components2;
    const { getPosition , getLimit  } = Move1;
    const { isEnough , getLength  } = Components2.Slides;
    const isLoop = Splide2.is(LOOP);
    const isSlide = Splide2.is(SLIDE);
    let currIndex = options.start || 0;
    let prevIndex = currIndex;
    let slideCount;
    let perMove;
    let perPage;
    function mount() {
        init();
        on([
            EVENT_UPDATED,
            EVENT_REFRESH
        ], init, DEFAULT_EVENT_PRIORITY - 1);
    }
    function init() {
        slideCount = getLength(true);
        perMove = options.perMove;
        perPage = options.perPage;
        currIndex = clamp(currIndex, 0, slideCount - 1);
    }
    function go(control, allowSameIndex, callback) {
        const dest = parse(control);
        if (options.useScroll) scroll(dest, true, true, options.speed, callback);
        else {
            const index = loop(dest);
            if (index > -1 && !Move1.isBusy() && (allowSameIndex || index !== currIndex)) {
                setIndex(index);
                Move1.move(dest, index, prevIndex, callback);
            }
        }
    }
    function scroll(destination, useIndex, snap, duration, callback) {
        const dest = useIndex ? destination : toDest(destination);
        Components2.Scroll.scroll(useIndex || snap ? Move1.toPosition(dest, true) : destination, duration, ()=>{
            setIndex(Move1.toIndex(Move1.getPosition()));
            callback && callback();
        });
    }
    function parse(control) {
        let index = currIndex;
        if (isString(control)) {
            const [, indicator, number] = control.match(/([+\-<>])(\d+)?/) || [];
            if (indicator === "+" || indicator === "-") index = computeDestIndex(currIndex + +`${indicator}${+number || 1}`, currIndex, true);
            else if (indicator === ">") index = number ? toIndex(+number) : getNext(true);
            else if (indicator === "<") index = getPrev(true);
        } else index = isLoop ? control : clamp(control, 0, getEnd());
        return index;
    }
    function getNext(destination) {
        return getAdjacent(false, destination);
    }
    function getPrev(destination) {
        return getAdjacent(true, destination);
    }
    function getAdjacent(prev, destination) {
        const number = perMove || (hasFocus() ? 1 : perPage);
        const dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex);
        if (dest === -1 && isSlide) {
            if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) return prev ? 0 : getEnd();
        }
        return destination ? dest : loop(dest);
    }
    function computeDestIndex(dest, from, incremental) {
        if (isEnough()) {
            const end = getEnd();
            if (dest < 0 || dest > end) {
                if (between(0, dest, from, true) || between(end, from, dest, true)) dest = toIndex(toPage(dest));
                else {
                    if (isLoop) dest = perMove || hasFocus() ? dest : dest < 0 ? -(slideCount % perPage || perPage) : slideCount;
                    else if (options.rewind) dest = dest < 0 ? end : 0;
                    else dest = -1;
                }
            } else if (!incremental && dest !== from) dest = perMove ? dest : toIndex(toPage(from) + (dest < from ? -1 : 1));
        } else dest = -1;
        return dest;
    }
    function getEnd() {
        let end = slideCount - perPage;
        if (hasFocus() || isLoop && perMove) end = slideCount - 1;
        return max(end, 0);
    }
    function loop(index) {
        if (isLoop) return isEnough() ? index % slideCount + (index < 0 ? slideCount : 0) : -1;
        return index;
    }
    function toIndex(page) {
        return clamp(hasFocus() ? page : perPage * page, 0, getEnd());
    }
    function toPage(index) {
        if (!hasFocus()) {
            index = between(index, slideCount - perPage, slideCount - 1) ? slideCount - 1 : index;
            index = floor(index / perPage);
        }
        return index;
    }
    function toDest(destination) {
        const closest = Move1.toIndex(destination);
        return isSlide ? clamp(closest, 0, getEnd()) : closest;
    }
    function setIndex(index) {
        if (index !== currIndex) {
            prevIndex = currIndex;
            currIndex = index;
        }
    }
    function getIndex(prev) {
        return prev ? prevIndex : currIndex;
    }
    function hasFocus() {
        return !isUndefined(options.focus) || options.isNavigation;
    }
    return {
        mount,
        go,
        scroll,
        getNext,
        getPrev,
        getAdjacent,
        getEnd,
        setIndex,
        getIndex,
        toIndex,
        toPage,
        toDest,
        hasFocus
    };
}
const XML_NAME_SPACE = "http://www.w3.org/2000/svg";
const PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
const SIZE = 40;
function Arrows(Splide2, Components2, options) {
    const { on , bind , emit  } = EventInterface(Splide2);
    const { classes , i18n  } = options;
    const { Elements: Elements2 , Controller: Controller2  } = Components2;
    let wrapper = Elements2.arrows;
    let prev = Elements2.prev;
    let next = Elements2.next;
    let created;
    const arrows = {
    };
    function mount() {
        init();
        on(EVENT_UPDATED, init);
    }
    function init() {
        if (options.arrows) {
            if (!prev || !next) createArrows();
        }
        if (prev && next) {
            if (!arrows.prev) {
                const { id  } = Elements2.track;
                setAttribute(prev, ARIA_CONTROLS, id);
                setAttribute(next, ARIA_CONTROLS, id);
                arrows.prev = prev;
                arrows.next = next;
                listen();
                emit(EVENT_ARROWS_MOUNTED, prev, next);
            } else display(wrapper, options.arrows === false ? "none" : "");
        }
    }
    function destroy() {
        if (created) remove(wrapper);
        else {
            removeAttribute(prev, ALL_ATTRIBUTES);
            removeAttribute(next, ALL_ATTRIBUTES);
        }
    }
    function listen() {
        const { go  } = Controller2;
        on([
            EVENT_MOUNTED,
            EVENT_MOVED,
            EVENT_UPDATED,
            EVENT_REFRESH,
            EVENT_SCROLLED
        ], update);
        bind(next, "click", ()=>{
            go(">", true);
        });
        bind(prev, "click", ()=>{
            go("<", true);
        });
    }
    function createArrows() {
        wrapper = create("div", classes.arrows);
        prev = createArrow(true);
        next = createArrow(false);
        created = true;
        append(wrapper, [
            prev,
            next
        ]);
        before(wrapper, child(options.arrows === "slider" && Elements2.slider || Splide2.root));
    }
    function createArrow(prev2) {
        const arrow = `<button class="${classes.arrow} ${prev2 ? classes.prev : classes.next}" type="button"><svg xmlns="${XML_NAME_SPACE}" viewBox="0 0 ${SIZE} ${SIZE}" width="${SIZE}" height="${SIZE}"><path d="${options.arrowPath || PATH}" />`;
        return parseHtml(arrow);
    }
    function update() {
        const index = Splide2.index;
        const prevIndex = Controller2.getPrev();
        const nextIndex = Controller2.getNext();
        const prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
        const nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
        prev.disabled = prevIndex < 0;
        next.disabled = nextIndex < 0;
        setAttribute(prev, ARIA_LABEL, prevLabel);
        setAttribute(next, ARIA_LABEL, nextLabel);
        emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
    }
    return {
        arrows,
        mount,
        destroy
    };
}
const INTERVAL_DATA_ATTRIBUTE = `${DATA_ATTRIBUTE}-interval`;
function Autoplay(Splide2, Components2, options) {
    const { on , bind , emit  } = EventInterface(Splide2);
    const interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), update);
    const { isPaused  } = interval;
    const { Elements: Elements3  } = Components2;
    let hovered;
    let focused;
    let paused;
    function mount() {
        const { autoplay  } = options;
        if (autoplay) {
            initButton(true);
            initButton(false);
            listen();
            if (autoplay !== "pause") play();
        }
    }
    function initButton(forPause) {
        const prop = forPause ? "pause" : "play";
        const button = Elements3[prop];
        if (button) {
            setAttribute(button, ARIA_CONTROLS, Elements3.track.id);
            setAttribute(button, ARIA_LABEL, options.i18n[prop]);
            bind(button, "click", forPause ? pause : play);
        }
    }
    function listen() {
        const { root  } = Elements3;
        if (options.pauseOnHover) bind(root, "mouseenter mouseleave", (e)=>{
            hovered = e.type === "mouseenter";
            autoToggle();
        });
        if (options.pauseOnFocus) bind(root, "focusin focusout", (e)=>{
            focused = e.type === "focusin";
            autoToggle();
        });
        on([
            EVENT_MOVE,
            EVENT_SCROLL,
            EVENT_REFRESH
        ], interval.rewind);
        on(EVENT_MOVE, updateInterval);
    }
    function play() {
        if (isPaused() && Components2.Slides.isEnough()) {
            interval.start(!options.resetProgress);
            focused = hovered = paused = false;
            emit(EVENT_AUTOPLAY_PLAY);
        }
    }
    function pause(manual = true) {
        if (!isPaused()) {
            interval.pause();
            emit(EVENT_AUTOPLAY_PAUSE);
        }
        paused = manual;
    }
    function autoToggle() {
        if (!paused) {
            if (!hovered && !focused) play();
            else pause(false);
        }
    }
    function update(rate) {
        const { bar  } = Elements3;
        bar && style(bar, "width", `${rate * 100}%`);
        emit(EVENT_AUTOPLAY_PLAYING, rate);
    }
    function updateInterval() {
        const Slide5 = Components2.Slides.getAt(Splide2.index);
        interval.set(Slide5 && +getAttribute(Slide5.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
    }
    return {
        mount,
        destroy: interval.cancel,
        play,
        pause,
        isPaused
    };
}
function Cover(Splide2, Components2, options) {
    const { on  } = EventInterface(Splide2);
    function mount() {
        if (options.cover) {
            on(EVENT_LAZYLOAD_LOADED, (img, Slide6)=>{
                toggle(true, img, Slide6);
            });
            on([
                EVENT_MOUNTED,
                EVENT_UPDATED,
                EVENT_REFRESH
            ], apply.bind(null, true));
        }
    }
    function destroy() {
        apply(false);
    }
    function apply(cover) {
        Components2.Slides.forEach((Slide7)=>{
            const img = child(Slide7.container || Slide7.slide, "img");
            if (img && img.src) toggle(cover, img, Slide7);
        });
    }
    function toggle(cover, img, Slide8) {
        Slide8.style("background", cover ? `center/cover no-repeat url("${img.src}")` : "", true);
        display(img, cover ? "none" : "");
    }
    return {
        mount,
        destroy
    };
}
const BOUNCE_DIFF_THRESHOLD = 10;
const BOUNCE_DURATION = 600;
const FRICTION_FACTOR = 0.6;
const BASE_VELOCITY = 1.5;
const MIN_DURATION = 800;
function Scroll(Splide2, Components2, options) {
    const { on , emit  } = EventInterface(Splide2);
    const { Move: Move2  } = Components2;
    const { getPosition , getLimit , exceededLimit  } = Move2;
    let interval;
    let scrollCallback;
    function mount() {
        on(EVENT_MOVE, clear);
        on([
            EVENT_UPDATED,
            EVENT_REFRESH
        ], cancel);
    }
    function scroll(destination, duration, callback, suppressConstraint) {
        const start = getPosition();
        let friction = 1;
        duration = duration || computeDuration(abs(destination - start));
        scrollCallback = callback;
        clear();
        interval = RequestInterval(duration, onScrolled, (rate)=>{
            const position = getPosition();
            const target = start + (destination - start) * easing(rate);
            const diff = (target - getPosition()) * friction;
            Move2.translate(position + diff);
            if (Splide2.is(SLIDE) && !suppressConstraint && exceededLimit()) {
                friction *= FRICTION_FACTOR;
                if (abs(diff) < BOUNCE_DIFF_THRESHOLD) bounce(exceededLimit(false));
            }
        }, 1);
        emit(EVENT_SCROLL);
        interval.start();
    }
    function bounce(backwards) {
        scroll(getLimit(!backwards), BOUNCE_DURATION, null, true);
    }
    function onScrolled() {
        const position = getPosition();
        const index = Move2.toIndex(position);
        if (!between(index, 0, Splide2.length - 1)) Move2.translate(Move2.shift(position, index > 0), true);
        scrollCallback && scrollCallback();
        emit(EVENT_SCROLLED);
    }
    function computeDuration(distance) {
        return max(distance / BASE_VELOCITY, MIN_DURATION);
    }
    function clear() {
        if (interval) interval.cancel();
    }
    function cancel() {
        if (interval && !interval.isPaused()) {
            clear();
            onScrolled();
        }
    }
    function easing(t) {
        const { easingFunc  } = options;
        return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
    }
    return {
        mount,
        destroy: clear,
        scroll,
        cancel
    };
}
const SCROLL_LISTENER_OPTIONS = {
    passive: false,
    capture: true
};
const FRICTION = 5;
const LOG_INTERVAL = 200;
const POINTER_DOWN_EVENTS = "touchstart mousedown";
const POINTER_MOVE_EVENTS = "touchmove mousemove";
const POINTER_UP_EVENTS = "touchend touchcancel mouseup";
function Drag(Splide2, Components2, options) {
    const { on , emit , bind , unbind  } = EventInterface(Splide2);
    const { Move: Move3 , Scroll: Scroll1 , Controller: Controller3  } = Components2;
    const { track  } = Components2.Elements;
    const { resolve , orient  } = Components2.Direction;
    const { getPosition , exceededLimit  } = Move3;
    let basePosition;
    let baseEvent;
    let prevBaseEvent;
    let lastEvent;
    let isFree;
    let dragging;
    let hasExceeded = false;
    let clickPrevented;
    let disabled;
    let target;
    function mount() {
        bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
        bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
        bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
        bind(track, "click", onClick, {
            capture: true
        });
        bind(track, "dragstart", prevent);
        on([
            EVENT_MOUNTED,
            EVENT_UPDATED
        ], init);
    }
    function init() {
        const { drag  } = options;
        disable(!drag);
        isFree = drag === "free";
    }
    function onPointerDown(e) {
        if (!disabled) {
            const { noDrag  } = options;
            const isTouch = isTouchEvent(e);
            const isDraggable = !noDrag || !matches(e.target, noDrag);
            clickPrevented = false;
            if (isDraggable && (isTouch || !e.button)) {
                if (!Move3.isBusy()) {
                    target = isTouch ? track : window;
                    prevBaseEvent = null;
                    lastEvent = null;
                    bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
                    bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
                    Move3.cancel();
                    Scroll1.cancel();
                    save(e);
                } else prevent(e, true);
            }
        }
    }
    function onPointerMove(e) {
        if (!lastEvent) emit(EVENT_DRAG);
        lastEvent = e;
        if (e.cancelable) {
            const diff = coordOf(e) - coordOf(baseEvent);
            if (dragging) {
                Move3.translate(basePosition + constrain(diff));
                const expired = timeOf(e) - timeOf(baseEvent) > LOG_INTERVAL;
                const exceeded = hasExceeded !== (hasExceeded = exceededLimit());
                if (expired || exceeded) save(e);
                emit(EVENT_DRAGGING);
                clickPrevented = true;
                prevent(e);
            } else {
                let { dragMinThreshold: thresholds  } = options;
                thresholds = isObject(thresholds) ? thresholds : {
                    mouse: 0,
                    touch: +thresholds || 10
                };
                dragging = abs(diff) > (isTouchEvent(e) ? thresholds.touch : thresholds.mouse);
                if (isSliderDirection()) prevent(e);
            }
        }
    }
    function onPointerUp(e) {
        unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
        unbind(target, POINTER_UP_EVENTS, onPointerUp);
        const { index  } = Splide2;
        if (lastEvent) {
            if (dragging || e.cancelable && isSliderDirection()) {
                const velocity = computeVelocity(e);
                const destination = computeDestination(velocity);
                if (isFree) Controller3.scroll(destination);
                else if (Splide2.is(FADE)) Controller3.go(index + orient(sign(velocity)));
                else Controller3.go(Controller3.toDest(destination), true);
                prevent(e);
            }
            emit(EVENT_DRAGGED);
        } else if (!isFree && getPosition() !== Move3.toPosition(index)) Controller3.go(index, true);
        dragging = false;
    }
    function save(e) {
        prevBaseEvent = baseEvent;
        baseEvent = e;
        basePosition = getPosition();
    }
    function onClick(e) {
        if (!disabled && clickPrevented) prevent(e, true);
    }
    function isSliderDirection() {
        const diffX = abs(coordOf(lastEvent) - coordOf(baseEvent));
        const diffY = abs(coordOf(lastEvent, true) - coordOf(baseEvent, true));
        return diffX > diffY;
    }
    function computeVelocity(e) {
        if (Splide2.is(LOOP) || !hasExceeded) {
            const base = baseEvent === lastEvent && prevBaseEvent || baseEvent;
            const diffCoord = coordOf(lastEvent) - coordOf(base);
            const diffTime = timeOf(e) - timeOf(base);
            const isFlick = timeOf(e) - timeOf(lastEvent) < LOG_INTERVAL;
            if (diffTime && isFlick) return diffCoord / diffTime;
        }
        return 0;
    }
    function computeDestination(velocity) {
        return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));
    }
    function coordOf(e, orthogonal) {
        return (isTouchEvent(e) ? e.touches[0] : e)[`page${resolve(orthogonal ? "Y" : "X")}`];
    }
    function timeOf(e) {
        return e.timeStamp;
    }
    function constrain(diff) {
        return diff / (hasExceeded && Splide2.is(SLIDE) ? FRICTION : 1);
    }
    function isTouchEvent(e) {
        return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
    }
    function isDragging() {
        return dragging;
    }
    function disable(value) {
        disabled = value;
    }
    return {
        mount,
        disable,
        isDragging
    };
}
const IE_ARROW_KEYS = [
    "Left",
    "Right",
    "Up",
    "Down"
];
const KEYBOARD_EVENT = "keydown";
function Keyboard(Splide2, Components2, options) {
    const { on , bind , unbind  } = EventInterface(Splide2);
    const { root  } = Splide2;
    const { resolve  } = Components2.Direction;
    let target;
    let disabled;
    function mount() {
        init();
        on(EVENT_UPDATED, onUpdated);
        on(EVENT_MOVE, onMove);
    }
    function init() {
        const { keyboard  } = options;
        if (keyboard) {
            if (keyboard === "focused") {
                target = root;
                setAttribute(root, TAB_INDEX, 0);
            } else target = window;
            bind(target, KEYBOARD_EVENT, onKeydown);
        }
    }
    function destroy() {
        unbind(target, KEYBOARD_EVENT);
        if (isHTMLElement(target)) removeAttribute(target, TAB_INDEX);
    }
    function disable(value) {
        disabled = value;
    }
    function onMove() {
        const _disabled = disabled;
        disabled = true;
        nextTick(()=>{
            disabled = _disabled;
        });
    }
    function onUpdated() {
        destroy();
        init();
    }
    function onKeydown(e) {
        if (!disabled) {
            const { key  } = e;
            const normalizedKey = includes(IE_ARROW_KEYS, key) ? `Arrow${key}` : key;
            if (normalizedKey === resolve("ArrowLeft")) Splide2.go("<");
            else if (normalizedKey === resolve("ArrowRight")) Splide2.go(">");
        }
    }
    return {
        mount,
        destroy,
        disable
    };
}
const SRC_DATA_ATTRIBUTE = `${DATA_ATTRIBUTE}-lazy`;
const SRCSET_DATA_ATTRIBUTE = `${SRC_DATA_ATTRIBUTE}-srcset`;
const IMAGE_SELECTOR = `[${SRC_DATA_ATTRIBUTE}], [${SRCSET_DATA_ATTRIBUTE}]`;
function LazyLoad(Splide2, Components2, options) {
    const { on , off , bind , emit  } = EventInterface(Splide2);
    const isSequential = options.lazyLoad === "sequential";
    let images = [];
    let index = 0;
    function mount() {
        if (options.lazyLoad) {
            init();
            on(EVENT_REFRESH, refresh);
            if (!isSequential) on([
                EVENT_MOUNTED,
                EVENT_REFRESH,
                EVENT_MOVED,
                EVENT_SCROLLED
            ], observe);
        }
    }
    function refresh() {
        destroy();
        init();
    }
    function init() {
        Components2.Slides.forEach((_Slide)=>{
            queryAll(_Slide.slide, IMAGE_SELECTOR).forEach((_img)=>{
                const src = getAttribute(_img, SRC_DATA_ATTRIBUTE);
                const srcset = getAttribute(_img, SRCSET_DATA_ATTRIBUTE);
                if (src !== _img.src || srcset !== _img.srcset) {
                    const className = options.classes.spinner;
                    const parent = _img.parentElement;
                    const _spinner = child(parent, `.${className}`) || create("span", className, parent);
                    setAttribute(_spinner, ROLE, "presentation");
                    images.push({
                        _img,
                        _Slide,
                        src,
                        srcset,
                        _spinner
                    });
                    !_img.src && display(_img, "none");
                }
            });
        });
        if (isSequential) loadNext();
    }
    function destroy() {
        index = 0;
        images = [];
    }
    function observe() {
        images = images.filter((data)=>{
            const distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
            if (data._Slide.isWithin(Splide2.index, distance)) return load(data);
            return true;
        });
        if (!images.length) off(EVENT_MOVED);
    }
    function load(data) {
        const { _img  } = data;
        addClass(data._Slide.slide, CLASS_LOADING);
        bind(_img, "load error", (e)=>{
            onLoad(data, e.type === "error");
        });
        [
            "src",
            "srcset"
        ].forEach((name)=>{
            if (data[name]) {
                setAttribute(_img, name, data[name]);
                removeAttribute(_img, name === "src" ? SRC_DATA_ATTRIBUTE : SRCSET_DATA_ATTRIBUTE);
            }
        });
    }
    function onLoad(data, error) {
        const { _Slide  } = data;
        removeClass(_Slide.slide, CLASS_LOADING);
        if (!error) {
            remove(data._spinner);
            display(data._img, "");
            emit(EVENT_LAZYLOAD_LOADED, data._img, _Slide);
            emit(EVENT_RESIZE);
        }
        if (isSequential) loadNext();
    }
    function loadNext() {
        if (index < images.length) load(images[index++]);
    }
    return {
        mount,
        destroy
    };
}
function Pagination(Splide2, Components2, options) {
    const { on , emit , bind , unbind  } = EventInterface(Splide2);
    const { Slides: Slides4 , Elements: Elements4 , Controller: Controller4  } = Components2;
    const { hasFocus , getIndex  } = Controller4;
    const items = [];
    let list;
    function mount() {
        init();
        on([
            EVENT_UPDATED,
            EVENT_REFRESH
        ], init);
        on([
            EVENT_MOVE,
            EVENT_SCROLLED
        ], update);
    }
    function init() {
        destroy();
        if (options.pagination && Slides4.isEnough()) {
            createPagination();
            emit(EVENT_PAGINATION_MOUNTED, {
                list,
                items
            }, getAt(Splide2.index));
            update();
        }
    }
    function destroy() {
        if (list) {
            remove(list);
            items.forEach((item)=>{
                unbind(item.button, "click");
            });
            empty(items);
            list = null;
        }
    }
    function createPagination() {
        const { length  } = Splide2;
        const { classes , i18n , perPage  } = options;
        const parent = options.pagination === "slider" && Elements4.slider || Elements4.root;
        const max4 = hasFocus() ? length : ceil(length / perPage);
        list = create("ul", classes.pagination, parent);
        for(let i = 0; i < max4; i++){
            const li = create("li", null, list);
            const button = create("button", {
                class: classes.page,
                type: "button"
            }, li);
            const controls = Slides4.getIn(i).map((Slide9)=>Slide9.slide.id
            );
            const text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
            bind(button, "click", onClick.bind(null, i));
            setAttribute(button, ARIA_CONTROLS, controls.join(" "));
            setAttribute(button, ARIA_LABEL, format(text, i + 1));
            items.push({
                li,
                button,
                page: i
            });
        }
    }
    function onClick(page) {
        Controller4.go(`>${page}`, true, ()=>{
            const Slide10 = Slides4.getAt(Controller4.toIndex(page));
            Slide10 && focus(Slide10.slide);
        });
    }
    function getAt(index) {
        return items[Controller4.toPage(index)];
    }
    function update() {
        const prev = getAt(getIndex(true));
        const curr = getAt(getIndex());
        if (prev) {
            removeClass(prev.button, CLASS_ACTIVE);
            removeAttribute(prev.button, ARIA_CURRENT);
        }
        if (curr) {
            addClass(curr.button, CLASS_ACTIVE);
            setAttribute(curr.button, ARIA_CURRENT, true);
        }
        emit(EVENT_PAGINATION_UPDATED, {
            list,
            items
        }, prev, curr);
    }
    return {
        items,
        mount,
        destroy,
        getAt,
        update
    };
}
const TRIGGER_KEYS = [
    " ",
    "Enter",
    "Spacebar"
];
function Sync(Splide2, Components2, options) {
    const { list  } = Components2.Elements;
    const events = [];
    function mount() {
        Splide2.splides.forEach((target)=>{
            !target.isParent && sync(target.splide);
        });
        if (options.isNavigation) navigate();
    }
    function destroy() {
        removeAttribute(list, ALL_ATTRIBUTES);
        events.forEach((event)=>{
            event.destroy();
        });
        empty(events);
    }
    function remount() {
        destroy();
        mount();
    }
    function sync(splide) {
        [
            Splide2,
            splide
        ].forEach((instance)=>{
            const event = EventInterface(instance);
            const target = instance === Splide2 ? splide : Splide2;
            event.on(EVENT_MOVE, (index, prev, dest)=>{
                target.go(target.is(LOOP) ? dest : index);
            });
            events.push(event);
        });
    }
    function navigate() {
        const event = EventInterface(Splide2);
        const { on  } = event;
        on(EVENT_CLICK, onClick);
        on(EVENT_SLIDE_KEYDOWN, onKeydown);
        on([
            EVENT_MOUNTED,
            EVENT_UPDATED
        ], update);
        setAttribute(list, ROLE, "menu");
        events.push(event);
        event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
    }
    function update() {
        setAttribute(list, ARIA_ORIENTATION, options.direction !== TTB ? "horizontal" : null);
    }
    function onClick(Slide11) {
        Splide2.go(Slide11.index);
    }
    function onKeydown(Slide12, e) {
        if (includes(TRIGGER_KEYS, e.key)) {
            onClick(Slide12);
            prevent(e);
        }
    }
    return {
        mount,
        destroy,
        remount
    };
}
function Wheel(Splide2, Components2, options) {
    const { bind  } = EventInterface(Splide2);
    function mount() {
        if (options.wheel) bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
    }
    function onWheel(e) {
        if (e.cancelable) {
            const { deltaY  } = e;
            if (deltaY) {
                const backwards = deltaY < 0;
                Splide2.go(backwards ? "<" : ">");
                shouldPrevent(backwards) && prevent(e);
            }
        }
    }
    function shouldPrevent(backwards) {
        return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
    }
    return {
        mount
    };
}
var ComponentConstructors = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Options: Options,
    Direction: Direction,
    Elements: Elements,
    Slides: Slides,
    Layout: Layout,
    Clones: Clones,
    Move: Move,
    Controller: Controller,
    Arrows: Arrows,
    Autoplay: Autoplay,
    Cover: Cover,
    Scroll: Scroll,
    Drag: Drag,
    Keyboard: Keyboard,
    LazyLoad: LazyLoad,
    Pagination: Pagination,
    Sync: Sync,
    Wheel: Wheel
});
const I18N = {
    prev: "Previous slide",
    next: "Next slide",
    first: "Go to first slide",
    last: "Go to last slide",
    slideX: "Go to slide %s",
    pageX: "Go to page %s",
    play: "Start autoplay",
    pause: "Pause autoplay"
};
const DEFAULTS = {
    type: "slide",
    speed: 400,
    waitForTransition: true,
    perPage: 1,
    cloneStatus: true,
    arrows: true,
    pagination: true,
    interval: 5000,
    pauseOnHover: true,
    pauseOnFocus: true,
    resetProgress: true,
    keyboard: true,
    easing: "cubic-bezier(0.25, 1, 0.5, 1)",
    drag: true,
    direction: "ltr",
    slideFocus: true,
    trimSpace: true,
    focusableNodes: "a, button, textarea, input, select, iframe",
    classes: CLASSES,
    i18n: I18N
};
function Fade(Splide2, Components2, options) {
    const { on  } = EventInterface(Splide2);
    function mount() {
        on([
            EVENT_MOUNTED,
            EVENT_REFRESH
        ], ()=>{
            nextTick(()=>{
                Components2.Slides.style("transition", `opacity ${options.speed}ms ${options.easing}`);
            });
        });
    }
    function start(index, done) {
        const { track  } = Components2.Elements;
        style(track, "height", unit(rect(track).height));
        nextTick(()=>{
            done();
            style(track, "height", "");
        });
    }
    return {
        mount,
        start,
        cancel: noop
    };
}
function Slide(Splide2, Components2, options) {
    const { bind  } = EventInterface(Splide2);
    const { Move: Move4 , Controller: Controller5  } = Components2;
    const { list  } = Components2.Elements;
    let endCallback;
    function mount() {
        bind(list, "transitionend", (e)=>{
            if (e.target === list && endCallback) {
                cancel();
                endCallback();
            }
        });
    }
    function start(index, done) {
        const destination = Move4.toPosition(index, true);
        const position = Move4.getPosition();
        const speed = getSpeed(index);
        if (abs(destination - position) >= 1 && speed >= 1) {
            apply(`transform ${speed}ms ${options.easing}`);
            Move4.translate(destination, true);
            endCallback = done;
        } else {
            Move4.jump(index);
            done();
        }
    }
    function cancel() {
        apply("");
    }
    function getSpeed(index) {
        const { rewindSpeed  } = options;
        if (Splide2.is(SLIDE) && rewindSpeed) {
            const prev = Controller5.getIndex(true);
            const end = Controller5.getEnd();
            if (prev === 0 && index >= end || prev >= end && index === 0) return rewindSpeed;
        }
        return options.speed;
    }
    function apply(transition) {
        style(list, "transition", transition);
    }
    return {
        mount,
        start,
        cancel
    };
}
const _Splide = class {
    constructor(target, options){
        this.event = EventBus();
        this.Components = {
        };
        this.state = State(CREATED);
        this.splides = [];
        this._options = {
        };
        this._Extensions = {
        };
        const root = isString(target) ? query(document, target) : target;
        assert(root, `${root} is invalid.`);
        this.root = root;
        merge(DEFAULTS, _Splide.defaults);
        merge(merge(this._options, DEFAULTS), options || {
        });
    }
    mount(Extensions, Transition) {
        const { state , Components: Components2  } = this;
        assert(state.is([
            CREATED,
            DESTROYED
        ]), "Already mounted!");
        state.set(CREATED);
        this._Components = Components2;
        this._Transition = Transition || this._Transition || (this.is(FADE) ? Fade : Slide);
        this._Extensions = Extensions || this._Extensions;
        const Constructors = assign({
        }, ComponentConstructors, this._Extensions, {
            Transition: this._Transition
        });
        forOwn(Constructors, (Component, key)=>{
            const component = Component(this, Components2, this._options);
            Components2[key] = component;
            component.setup && component.setup();
        });
        forOwn(Components2, (component)=>{
            component.mount && component.mount();
        });
        this.emit(EVENT_MOUNTED);
        addClass(this.root, CLASS_INITIALIZED);
        state.set(IDLE);
        this.emit(EVENT_READY);
        return this;
    }
    sync(splide) {
        this.splides.push({
            splide
        });
        splide.splides.push({
            splide: this,
            isParent: true
        });
        if (this.state.is(IDLE)) {
            this._Components.Sync.remount();
            splide.Components.Sync.remount();
        }
        return this;
    }
    go(control) {
        this._Components.Controller.go(control);
        return this;
    }
    on(events, callback) {
        this.event.on(events, callback, null, DEFAULT_USER_EVENT_PRIORITY);
        return this;
    }
    off(events) {
        this.event.off(events);
        return this;
    }
    emit(event) {
        this.event.emit(event, ...slice(arguments, 1));
        return this;
    }
    add(slides, index) {
        this._Components.Slides.add(slides, index);
        return this;
    }
    remove(matcher) {
        this._Components.Slides.remove(matcher);
        return this;
    }
    is(type) {
        return this._options.type === type;
    }
    refresh() {
        this.emit(EVENT_REFRESH);
        return this;
    }
    destroy(completely = true) {
        const { event , state  } = this;
        if (state.is(CREATED)) event.on(EVENT_READY, this.destroy.bind(this, completely), this);
        else {
            forOwn(this._Components, (component)=>{
                component.destroy && component.destroy(completely);
            }, true);
            event.emit(EVENT_DESTROY);
            event.destroy();
            completely && empty(this.splides);
            state.set(DESTROYED);
        }
        return this;
    }
    get options() {
        return this._options;
    }
    set options(options) {
        const { _options  } = this;
        merge(_options, options);
        if (!this.state.is(CREATED)) this.emit(EVENT_UPDATED, _options);
    }
    get length() {
        return this._Components.Slides.getLength(true);
    }
    get index() {
        return this._Components.Controller.getIndex();
    }
};
let Splide = _Splide;
Splide.defaults = {
};
Splide.STATES = STATES;
const CLASS_RENDERED = "is-rendered";
const RENDERER_DEFAULT_CONFIG = {
    listTag: "ul",
    slideTag: "li"
};
class Style {
    constructor(id, options){
        this.styles = {
        };
        this.id = id;
        this.options = options;
    }
    rule(selector, prop, value, breakpoint) {
        breakpoint = breakpoint || "default";
        const selectors = this.styles[breakpoint] = this.styles[breakpoint] || {
        };
        const styles = selectors[selector] = selectors[selector] || {
        };
        styles[prop] = value;
    }
    build() {
        let css = "";
        if (this.styles.default) css += this.buildSelectors(this.styles.default);
        Object.keys(this.styles).sort((n, m)=>this.options.mediaQuery === "min" ? +n - +m : +m - +n
        ).forEach((breakpoint)=>{
            if (breakpoint !== "default") {
                css += `@media screen and (max-width: ${breakpoint}px) {`;
                css += this.buildSelectors(this.styles[breakpoint]);
                css += `}`;
            }
        });
        return css;
    }
    buildSelectors(selectors) {
        let css = "";
        forOwn(selectors, (styles, selector)=>{
            selector = `#${this.id} ${selector}`.trim();
            css += `${selector} {`;
            forOwn(styles, (value, prop)=>{
                if (value || value === 0) css += `${prop}: ${value};`;
            });
            css += "}";
        });
        return css;
    }
}
class SplideRenderer {
    constructor(contents, options, config, defaults){
        this.slides = [];
        this.options = {
        };
        this.breakpoints = [];
        merge(DEFAULTS, defaults || {
        });
        merge(merge(this.options, DEFAULTS), options || {
        });
        this.contents = contents;
        this.config = assign({
        }, RENDERER_DEFAULT_CONFIG, config || {
        });
        this.id = this.config.id || uniqueId("splide");
        this.Style = new Style(this.id, this.options);
        this.Direction = Direction(null, null, this.options);
        assert(this.contents.length, "Provide at least 1 content.");
        this.init();
    }
    static clean(splide) {
        const { on  } = EventInterface(splide);
        const { root  } = splide;
        const clones = queryAll(root, `.${CLASS_CLONE}`);
        on(EVENT_MOUNTED, ()=>{
            remove(child(root, "style"));
        });
        remove(clones);
    }
    init() {
        this.parseBreakpoints();
        this.initSlides();
        this.registerRootStyles();
        this.registerTrackStyles();
        this.registerSlideStyles();
        this.registerListStyles();
    }
    initSlides() {
        push(this.slides, this.contents.map((content, index)=>{
            content = isString(content) ? {
                html: content
            } : content;
            content.styles = content.styles || {
            };
            content.attrs = content.attrs || {
            };
            this.cover(content);
            const classes = `${this.options.classes.slide} ${index === 0 ? CLASS_ACTIVE : ""}`;
            assign(content.attrs, {
                class: `${classes} ${content.attrs.class || ""}`.trim(),
                style: this.buildStyles(content.styles)
            });
            return content;
        }));
        if (this.isLoop()) this.generateClones(this.slides);
    }
    registerRootStyles() {
        this.breakpoints.forEach(([width, options])=>{
            this.Style.rule(" ", "max-width", unit(options.width), width);
        });
    }
    registerTrackStyles() {
        const { Style: Style2  } = this;
        const selector = `.${CLASS_TRACK}`;
        this.breakpoints.forEach(([width, options])=>{
            Style2.rule(selector, this.resolve("paddingLeft"), this.cssPadding(options, false), width);
            Style2.rule(selector, this.resolve("paddingRight"), this.cssPadding(options, true), width);
            Style2.rule(selector, "height", this.cssTrackHeight(options), width);
        });
    }
    registerListStyles() {
        const { Style: Style2  } = this;
        const selector = `.${CLASS_LIST}`;
        this.breakpoints.forEach(([width, options])=>{
            Style2.rule(selector, "transform", this.buildTranslate(options), width);
            if (!this.cssSlideHeight(options)) Style2.rule(selector, "aspect-ratio", this.cssAspectRatio(options), width);
        });
    }
    registerSlideStyles() {
        const { Style: Style2  } = this;
        const selector = `.${CLASS_SLIDE}`;
        this.breakpoints.forEach(([width, options])=>{
            Style2.rule(selector, "width", this.cssSlideWidth(options), width);
            Style2.rule(selector, "height", this.cssSlideHeight(options) || "100%", width);
            Style2.rule(selector, this.resolve("marginRight"), unit(options.gap) || "0px", width);
            Style2.rule(`${selector} > img`, "display", options.cover ? "none" : "inline", width);
        });
    }
    buildTranslate(options) {
        const { resolve , orient  } = this.Direction;
        const values = [];
        values.push(this.cssOffsetClones(options));
        values.push(this.cssOffsetGaps(options));
        if (this.isCenter(options)) {
            values.push(this.buildCssValue(orient(-50), "%"));
            values.push(...this.cssOffsetCenter(options));
        }
        return values.filter(Boolean).map((value)=>`translate${resolve("X")}(${value})`
        ).join(" ");
    }
    cssOffsetClones(options) {
        const { resolve , orient  } = this.Direction;
        const cloneCount = this.getCloneCount();
        if (this.isFixedWidth(options)) {
            const { value , unit: unit2  } = this.parseCssValue(options[resolve("fixedWidth")]);
            return this.buildCssValue(orient(value) * cloneCount, unit2);
        }
        const percent = 100 * cloneCount / options.perPage;
        return `${orient(percent)}%`;
    }
    cssOffsetCenter(options) {
        const { resolve , orient  } = this.Direction;
        if (this.isFixedWidth(options)) {
            const { value , unit: unit2  } = this.parseCssValue(options[resolve("fixedWidth")]);
            return [
                this.buildCssValue(orient(value / 2), unit2)
            ];
        }
        const values = [];
        const { perPage , gap  } = options;
        values.push(`${orient(50 / perPage)}%`);
        if (gap) {
            const { value , unit: unit2  } = this.parseCssValue(gap);
            const gapOffset = (value / perPage - value) / 2;
            values.push(this.buildCssValue(orient(gapOffset), unit2));
        }
        return values;
    }
    cssOffsetGaps(options) {
        const cloneCount = this.getCloneCount();
        if (cloneCount && options.gap) {
            const { orient  } = this.Direction;
            const { value , unit: unit2  } = this.parseCssValue(options.gap);
            if (this.isFixedWidth(options)) return this.buildCssValue(orient(value * cloneCount), unit2);
            const { perPage  } = options;
            const gaps = cloneCount / perPage;
            return this.buildCssValue(orient(gaps * value), unit2);
        }
        return "";
    }
    resolve(prop) {
        return camelToKebab(this.Direction.resolve(prop));
    }
    cssPadding(options, right) {
        const { padding  } = options;
        const prop = this.Direction.resolve(right ? "right" : "left", true);
        return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
    }
    cssTrackHeight(options) {
        let height = "";
        if (this.isVertical()) {
            height = this.cssHeight(options);
            assert(height, '"height" is missing.');
            height = `calc(${height} - ${this.cssPadding(options, false)} - ${this.cssPadding(options, true)})`;
        }
        return height;
    }
    cssHeight(options) {
        return unit(options.height);
    }
    cssSlideWidth(options) {
        return options.autoWidth ? "" : unit(options.fixedWidth) || (this.isVertical() ? "" : this.cssSlideSize(options));
    }
    cssSlideHeight(options) {
        return unit(options.fixedHeight) || (this.isVertical() ? options.autoHeight ? "" : this.cssSlideSize(options) : this.cssHeight(options));
    }
    cssSlideSize(options) {
        const gap = unit(options.gap);
        return `calc((100%${gap && ` + ${gap}`})/${options.perPage || 1}${gap && ` - ${gap}`})`;
    }
    cssAspectRatio(options) {
        const { heightRatio  } = options;
        return heightRatio ? `${1 / heightRatio}` : "";
    }
    buildCssValue(value, unit2) {
        return `${value}${unit2}`;
    }
    parseCssValue(value) {
        if (isString(value)) {
            const number = parseFloat(value) || 0;
            const unit2 = value.replace(/\d*(\.\d*)?/, "") || "px";
            return {
                value: number,
                unit: unit2
            };
        }
        return {
            value,
            unit: "px"
        };
    }
    parseBreakpoints() {
        const { breakpoints  } = this.options;
        this.breakpoints.push([
            "default",
            this.options
        ]);
        if (breakpoints) forOwn(breakpoints, (options, width)=>{
            this.breakpoints.push([
                width,
                merge(merge({
                }, this.options), options)
            ]);
        });
    }
    isFixedWidth(options) {
        return !!options[this.Direction.resolve("fixedWidth")];
    }
    isLoop() {
        return this.options.type === LOOP;
    }
    isCenter(options) {
        if (options.focus === "center") {
            if (this.isLoop()) return true;
            if (this.options.type === SLIDE) return !this.options.trimSpace;
        }
        return false;
    }
    isVertical() {
        return this.options.direction === TTB;
    }
    buildClasses() {
        const { options  } = this;
        return [
            CLASS_ROOT,
            `${CLASS_ROOT}--${options.type}`,
            `${CLASS_ROOT}--${options.direction}`,
            options.drag && `${CLASS_ROOT}--draggable`,
            options.isNavigation && `${CLASS_ROOT}--nav`,
            CLASS_ACTIVE,
            !this.config.hidden && CLASS_RENDERED
        ].filter(Boolean).join(" ");
    }
    buildAttrs(attrs) {
        let attr = "";
        forOwn(attrs, (value, key)=>{
            attr += value ? ` ${camelToKebab(key)}="${value}"` : "";
        });
        return attr.trim();
    }
    buildStyles(styles) {
        let style2 = "";
        forOwn(styles, (value, key)=>{
            style2 += ` ${camelToKebab(key)}:${value};`;
        });
        return style2.trim();
    }
    renderSlides() {
        const { slideTag: tag  } = this.config;
        return this.slides.map((content)=>{
            return `<${tag} ${this.buildAttrs(content.attrs)}>${content.html || ""}</${tag}>`;
        }).join("");
    }
    cover(content) {
        const { styles , html =""  } = content;
        if (this.options.cover && !this.options.lazyLoad) {
            const src = html.match(/<img.*?src\s*=\s*(['"])(.+?)\1.*?>/);
            if (src && src[2]) styles.background = `center/cover no-repeat url('${src[2]}')`;
        }
    }
    generateClones(contents) {
        const { classes  } = this.options;
        const count = this.getCloneCount();
        const slides = contents.slice();
        while(slides.length < count)push(slides, slides);
        push(slides.slice(-count).reverse(), slides.slice(0, count)).forEach((content, index)=>{
            const attrs = assign({
            }, content.attrs, {
                class: `${content.attrs.class} ${classes.clone}`
            });
            const clone = assign({
            }, content, {
                attrs
            });
            index < count ? contents.unshift(clone) : contents.push(clone);
        });
    }
    getCloneCount() {
        if (this.isLoop()) {
            const { options  } = this;
            if (options.clones) return options.clones;
            const perPage = max(...this.breakpoints.map(([, options2])=>options2.perPage
            ));
            return perPage * ((options.flickMaxPages || 1) + 1);
        }
        return 0;
    }
    renderArrows() {
        let html = "";
        html += `<div class="${this.options.classes.arrows}">`;
        html += this.renderArrow(true);
        html += this.renderArrow(false);
        html += `</div>`;
        return html;
    }
    renderArrow(prev) {
        const { classes , i18n  } = this.options;
        const attrs = {
            class: `${classes.arrow} ${prev ? classes.prev : classes.next}`,
            type: "button",
            ariaLabel: prev ? i18n.prev : i18n.next
        };
        return `<button ${this.buildAttrs(attrs)}><svg xmlns="${XML_NAME_SPACE}" viewBox="0 0 ${SIZE} ${SIZE}" width="${SIZE}" height="${SIZE}"><path d="${this.options.arrowPath || PATH}" /></svg></button>`;
    }
    html() {
        const { rootClass , listTag , arrows , beforeTrack , afterTrack , slider , beforeSlider , afterSlider  } = this.config;
        let html = "";
        html += `<div id="${this.id}" class="${this.buildClasses()} ${rootClass || ""}">`;
        html += `<style>${this.Style.build()}</style>`;
        if (slider) {
            html += beforeSlider || "";
            html += `<div class="splide__slider">`;
        }
        html += beforeTrack || "";
        if (arrows) html += this.renderArrows();
        html += `<div class="splide__track">`;
        html += `<${listTag} class="splide__list">`;
        html += this.renderSlides();
        html += `</${listTag}>`;
        html += `</div>`;
        html += afterTrack || "";
        if (slider) {
            html += `</div>`;
            html += afterSlider || "";
        }
        html += `</div>`;
        return html;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"1SEZe":[function() {},{}]},["5u3zE","14Tjh"], "14Tjh", "parcelRequire6566")

</script>
        <!-----------End of Splide Components import-->

        <link rel="stylesheet" href="/index.4d663569.css">
        <title>Water Warriors Singapore</title>
    </head>
    <body>
        <div id="imgHero">
            <div class="intro">
                <h1>Water Warriors Singapore</h1>
                <h4>Education for the protection and Conservation of water</h4>
                <br>
                <p class="welcome">The world may have come to a standstill, but the fight to save water for our future rages on.</p>
                <br>
                <sl-button size="large" pill="" class="intro-btn" variant="default" href="#navbar" caret="">Learn how you can play your part!</sl-button>
    
            </div>
        </div>
        

    
            <div id="navbar">
                <sl-drawer open="" id="phoneNav">
                    <a href="#water_Value">The Value of Water</a>
                    <a href="#water_Uses">Uses of Water</a>
                    <a href="#water_Sustains">How water sustains nature</a>
                    <a href="#conserveH2O">Why Conserve water?</a>
                    <a href="#waterAvail">How much water do we have?</a>
                    <a href="#consq">The consequences of no water</a>
                    <a href="#waterSupplies">Protecting our Water</a>
                    <sl-button slot="footer" variant="primary" id="phoneNavBtnClose">Close</sl-button>
                </sl-drawer>
                <sl-icon-button id="phoneNavBtn" style="font-size: 2rem;" name="list" label="Menu"></sl-icon-button>
                <div id="browserNav">
                    <div>
                        <sl-tooltip content="The Value of Water" placement="right">
                            <sl-button variant="primary" size="medium" circle="" href="#water_Value"></sl-button>
                        </sl-tooltip>
                    </div>
                    <div>
                        <sl-tooltip content="Uses of Water" placement="right">
                            <sl-button variant="primary" size="medium" circle="" href="#water_Uses"></sl-button>
                        </sl-tooltip>
                    </div>
                    
                    <div>
                        <sl-tooltip content="How water sustains nature" placement="right">
                            <sl-button variant="primary" size="medium" circle="" href="#water_Sustains"></sl-button>
                        </sl-tooltip>
                    </div>
                    
                    <div>
                        <sl-tooltip content="Why Conserve water?" placement="right">
                            <sl-button variant="primary" size="medium" circle="" href="#conserveH2O"></sl-button>
                        </sl-tooltip>
                    </div>
                    
                    <div>
                        <sl-tooltip content="How much water do we have?" placement="right">
                            <sl-button variant="primary" size="medium" circle="" href="#waterAvail"></sl-button>
                        </sl-tooltip>
                    </div>
                   
                    <div>
                        <sl-tooltip content="The consequences of no water" placement="right">
                            <sl-button variant="primary" size="medium" circle="" href="#consq"></sl-button>
                        </sl-tooltip>
                    </div>
                    
                    <div>
                        <sl-tooltip hoist="" content="Protecting our Water" placement="right">
                            <sl-button variant="primary" size="medium" circle="" href="#waterSupplies"></sl-button>
                        </sl-tooltip>
                    </div>
                    
                </div>
                    
            </div>
            
            <div class="value_h2O">
                
                <section id="water_Value">
                    <div class="section-waterValue">
                        <h2>The Value of Water</h2>
                        
                        <p>Water is very important to each and every one of us.</p>
                        <p>Click on the buttons bellow to find out the details!</p>
        
                        

                        <div class="valueWater_btns">
                            <div class="valueWater_img">
                                <a href="#water_Uses">
                                    <p class="waterUses_btn">Uses of Water</p>
                                    <img src="/woman-drinking-bottle-water.f2819169.png" alt="Uses of water button">
                                </a>
                            </div>                            

                            <div class="valueWater_img">
                                <a href="#water_Sustains">
                                    <p class="waterSustains_btn">How water sustains nature</p>
                                    <img src="/sea_Turtle.625bfc4c.png" alt="How water sustains nature button">
                                </a>
                            </div>                           
                                                      
                        </div>
                                                   
                    </div>
                </section>

                <section id="water_Uses">
                        <h3 class="section-waterUses_Title">Uses of water</h3>
                        <p>In our daily lives, there are many things that clearly use water. </p>
                        <p>Take a look through this slide show. Are there any items inside that surprise you?</p>
                        <div class="splide" id="slide_waterUses">
                            <div class="splide__track">
                                <ul class="splide__list">
                                    <li class="splide__slide">
                                        <div class="splide__slide__container">
                                            <img src="/Glass-of-water.9c59dfed.jpg" alt="pouring water into cup" class="water_Uses_img">
                                        </div>
                                        
                                    </li>
                                    <li class="splide__slide">
                                        <div class="splide__slide__container">
                                            <img src="/foodfromWater.e590c902.png" alt="Food from water" class="water_Uses_img">
                                        </div>
                                        
                                    </li>
                        
                                    <li class="splide__slide">
                                        <div class="splide__slide__container">
                                            <img src="/CleaningFood.b9a6ce23.jpg" alt="Washing food for cooking" class="water_Uses_img">
                                        </div>
                                        
                                    </li>
                                    <li class="splide__slide">
                                        <div class="splide__slide__container">
                                            <img src="/pexels-ketut-subiyanto-4546141.b567d0ea.jpg" alt="boy looking at mirror while brushing teeth" class="water_Uses_img">
                                        </div>
                                        
                                    </li>
                                    <li class="splide__slide">
                                        <div class="splide__slide__container">
                                            <img src="/pexels-ketut-subiyanto-4546167.36b09212.jpg" alt="boy putting clothes into washing machine" class="water_Uses_img">
                                        </div>
                                        
                                    </li>
                                    <li class="splide__slide">
                                        <div class="splide__slide__container">
                                            <img src="/Beach_youwall.61e5906a.jpg" alt="Beach scene" class="water_Uses_img">
                                        </div>
                                        
                                    </li>
                                    <li class="splide__slide">
                                        <div class="splide__slide__container">
                                            <img src="/woman-drinking-bottle-water.7a2bc6f7.jpg" alt="woman drinking from water bottle" class="water_Uses_img">
                                        </div>
                                        
                                    </li>

                                </ul>
                            </div>
                        </div> 
                        

                    
                </section>

                <section id="water_Sustains">
                    <div class="section-waterSustains">
                        <h3> How water sustains nature</h3>
                        <br>
                        <p id="waterSustains_para">Click the Animals and Plants to see how they interact with Nature everyday!</p>
                        <div class="waterSustains_collagesht">
                            <!-----Creating Overlay and full image-->
                            <div id="overlayCollage01" class="collageOverlay">
                                <div>
                                    <img class="overlay-Content" id="img01" src="/africa-deer-drinking-water.3ebee03e.png" alt="african deers drinking water">
                                    <sl-button type="primary" pill="" class="overlay-CloseBtn">Close Button</sl-button>
                                </div>                                
                            </div>
    
                            <div id="overlayCollage02" class="collageOverlay">
                                <div>
                                    <img class="overlay-Content" id="img02" src="/Frog_During_Rain.6ee84823.jpg" alt="frog taking shelter under leaf from rain">
                                    <sl-button type="primary" pill="" class="overlay-CloseBtn">Close Button</sl-button>
                                </div>
                                
                            </div>
    
                            <div id="overlayCollage03" class="collageOverlay">
                                <div>
                                    <img class="overlay-Content" id="img03" src="/Bird_drinking_Water.4cd58449.png" alt="bird drinking water">
                                    <sl-button type="primary" pill="" class="overlay-CloseBtn">Close Button</sl-button>
                                </div>                                
                            </div>
    
                            <div id="overlayCollage04" class="collageOverlay">
                                <div>
                                    <img class="overlay-Content" id="img04" src="/12_YT_SPARROW_1391748f.09f15205.jpg" alt="Sparrow drinking and playing from bird bath">
                                    <sl-button type="primary" pill="" class="overlay-CloseBtn">Close Button</sl-button>
                                </div>                                
                            </div>
    
                            <div id="overlayCollage05" class="collageOverlay">
                                <div>
                                    <img class="overlay-Content" id="img05" src="/pexels-harrison-haines-3536511.1b37278b.jpg" alt="school of fish swimming in pattern">
                                    <sl-button type="primary" pill="" class="overlay-CloseBtn">Close Button</sl-button>
                                </div>                                
                            </div>
    
                            <div id="overlayCollage06" class="collageOverlay">
                                <div>
                                    <img class="overlay-Content" id="img06" src="/pexels-holiho-1112186.dcabed88.jpg" alt="forest pathway">
                                    <sl-button type="primary" pill="" class="overlay-CloseBtn">Close Button</sl-button>
                                </div>                                
                            </div>

                            <!----Creating the collage picture-->
                            <div class="waterSustains_collagepic">
                                <img class="ws-collagePic" id="collagePic1" src="/africa-deer-drinking-water-preview.b3c390d1.png" alt="african deers drinking water (thumbnail)">
                                <img class="ws-collagePic" id="collagePic2" src="/Frog_During_Rain_preview.e61a4658.png" alt="frog taking shelter under leaf from rain (thumbnail)">
                                <img class="ws-collagePic" id="collagePic3" src="/Bird_drinking_Water_preview.1df63a6d.png" alt="bird drinking water (thumbnail)">
                                <img class="ws-collagePic" id="collagePic4" src="/12_YT_SPARROW_preview.23bb3b70.png" alt="Sparrow drinking and playing from bird bath (thumbnail)">
                                <img class="ws-collagePic" id="collagePic5" src="/Fishes-swiming-preview.37bfb84a.png" alt="school of fish swimming in pattern (thumbnail)">
                                <img class="ws-collagePic" id="collagePic6" src="/pexels-holiho-forest-preview.cd4fff68.png" alt="forest pathway (thumbnail)">
                            </div>
                            
                        </div>
                        
                        

                        
                    </div>
                    
                </section>
            </div>

            <div id="waterNeeded">
                <section id="conserveH2O">
                    <div class="section-waterConserve">
                        <h2>Why Conserve Water?</h2>
                        <h3>How much water do we really need?</h3>
                        <sl-tab-group class="waterNeed-demo" activation="manual">
                            <sl-tab slot="nav" panel="waterTrend" id="waterTrend-btn">Show Water Demand Trend</sl-tab>
                            <sl-tab slot="nav" panel="waterUsage" id="waterUsage-btn">Show Breakdown of Water usage in Household</sl-tab>
                            
                            <sl-tab-panel name="waterTrend">
                                <img class="waterNeed-img" src="/Population-and-water-demand-in-Singapore-18.ppm.466457e4.png" id="waterTrends" alt="population growth in Singapore and water demand over the years">
                                <p id="waterNeeds">At this rate, there will be <span id="waterNeeds-Highlight">No water</span> left!</p>
                            </sl-tab-panel>
                            <sl-tab-panel name="waterUsage">
                                <img class="waterNeed-img" src="/WaterUsage-PieChart.38b2787e.jpg" id="waterUsage" alt="Water Usage PIE chart from 2018/2019 PUB water consumption study">                                
                            </sl-tab-panel>
                            
                        </sl-tab-group>
                    </div>
                </section>

                <section>
                    <div class="section-waterAvail" id="waterAvail">
                        <h3>How much water do we have?</h3>
                        <p>Ever wondered how much each national tap adds to our water supplies? Click to find out more!</p>
                        <div class="waterAvail-gallery">
                            <div class="waterAvail-img">
                                <sl-tooltip placement="bottom" content="Imported Water from our nearest neighbour alongside rain water make up to 35% of our water sources currently.">
                                    <img src="/Imported_water_sq.d7cccf79.png" alt="Pipes with Water from Malaysia">
                                </sl-tooltip>
                            </div>
                            
                            <div class="waterAvail-img">
                                <sl-tooltip placement="bottom" content="NEWater make up to 40% of our water sources currently">
                                    <img src="/NEWaterPlant_exteriorSq.b1a863db.png" alt="Exterior of a NEWater plant">
                                </sl-tooltip> 
                            </div>
                            
                            <div class="waterAvail-img">
                                <sl-tooltip placement="bottom" content="Desalinated water treated make up to 25% of our water sources currently">
                                    <img src="/Tuas-Desalination-Plant-sq.faf14543.png" alt="Exterior of the Desalination plant in Tuas">
                                </sl-tooltip>
                            </div>
                            
                                                                                 
                        </div>
                    </div>
                </section>

                <section id="consq">
                    <h3>Consequences of No Water</h3>
                    <p>Click on the images in he collage to see the consequences of having no water.</p>
                    <sl-dialog label="Dialog" class="dialog-bird-drinking">
                        Certain animals will lose their food sources.
                        <sl-button slot="footer" variant="default">Close tab</sl-button>
                    </sl-dialog>
                    <div class="consequences-imgGallery"> 
                        <sl-tooltip hoist="" id="city_lake" placement="top" content="We lose the things that make up our beautiful landscapes" trigger="click">
                            <img src="/sea_B4_City.6f7ac96b.jpg" alt="city view from a lake-side">
                        </sl-tooltip>   
                        <div class="consequences-imgCollage">                       
                                                                                
                            <div id="consequences-bird">
                                <sl-tooltip hoist="" placement="top" content="Certain animals will lose their food sources." trigger="click">
                                    <img src="/Bird_drinking_Water_preview.1df63a6d.png" alt="bird catching fish from waters">
                                </sl-tooltip>
                            </div>                   
                            
                            <div>                                
                                
                                <div id="consequences-deer">
                                    <sl-tooltip hoist="" placement="top" content="We lose our sources of hydration and eventually die of thirst." trigger="click">
                                        <img src="/pexels-esteban-arango-deer.77579d81.png" alt="deer drinking from river">
                                    </sl-tooltip>
                                </div>
                                
                                <div id="consequences-forest">
                                    <sl-tooltip hoist="" placement="top" content="Plants will wither and die, and the soil gets eroded without the plants roots to anchor them." trigger="click">
                                        <img src="/pexels-holiho-forest-preview.cd4fff68.png" alt="pathway through the forest">
                                    </sl-tooltip> 
                                </div>

                                <div id="consequences-Turtle">
                                    <sl-tooltip hoist="" placement="top" content="Creatures of the water will lose their habitats." trigger="click">
                                        <img src="/sea_Turtle-preview.3d8bb615.png" alt="turtle swimming">
                                    </sl-tooltip>
                                </div>
                                
                            </div>
                            
                                           
                            
                        </div>
                        
                    </div>
                </section>
                                    
            </div>

            <div class="proteccH2O" id="waterSupplies">
               
                    <section>
                        <h2>Protecting Singapore's Water</h2>
                        <h3>Sources of Water in Singapore</h3>

                        <p>Ever wondered what happens to the water before it is pumped into Singapore's water supply?</p>
                        <p>Click on the images to find out more!</p>

                        <div id="supply-Gallery">
                                <div class="flip-card">
                                        <div class="flip-card-inner">
                                            <div class="flip-card-front">
                                                <img src="/water-Pipes_CNA.8669475d.png" class="waterSupply-GalleryImg" alt="Water pipes to carry water all around Singapore">
                                            </div>
                                            <div class="flip-card-back">
                                                <h6 class="flip-card-TitleTxt">Water catchments and Drainages </h6>
                                                <p class="flip-card-Txt">Water is collected from the water catchments and drains and sent along via the water pipes for treatment.</p>
                                            </div>
                                        </div>   
                                     
                                </div>                            
                          
                                <div class="flip-card" id="card-desalinationPlant">
                                        <div class="flip-card-inner">
                                            <div class="flip-card-front">
                                                <img src="/Tuas-Desalination-Plant.4367258e.jpg" class="waterSupply-GalleryImg" alt="water treatment plant">
                                            </div>
                                            <div class="flip-card-back">
                                                <h6 class="flip-card-TitleTxt">Water Treatment </h6>
                                                <p class="flip-card-Txt">At water treatment plants, water is chemically treated, filtered and disinfected, thereby making it safe for drinking.</p>
                                            </div>
                                        </div>
                                        
                                </div>                            

                                <div class="flip-card" id="card-NEWater">
                                        <div class="flip-card-inner">
                                            <div class="flip-card-front">
                                                <img src="/NEWaterPlant_exterior.f656a358.png" class="waterSupply-GalleryImg" alt="NEWwater tanks">
                                            </div>
                                            <div class="flip-card-back">
                                                <h6 class="flip-card-TitleTxt"> Water Tanks </h6>
                                                <p class="flip-card-Txt">Water is then channeled to water tanks, ready to be pumped into our reservoirs.</p>
                                            </div>
                                        </div>

                                        
                                </div>                            

                                <div class="flip-card" id="card-reservoir">
                                        <div class="flip-card-inner">
                                            <div class="flip-card-front">
                                                <img src="/singapore-marinabarragereservoir_PUB.ff974069.jpg" class="waterSupply-GalleryImg" alt="Aerial photo of Marina Barrage reservoir">
                                            </div>
                                            <div class="flip-card-back">
                                                <h6 class="flip-card-TitleTxt">Reservoirs </h6>
                                                <p class="flip-card-Txt">Water is finally pumped out for our use at home or in our industries.</p>
                                            </div>
                                        </div>
                                        
                                </div>
                                                       
                        </div>                     
                        <div class="footer">
                            <sl-button size="large" pill="" class="footer-btn" href="#water_Value">Back to top <sl-icon name="chevron-up"></sl-icon></sl-button>
                        </div>
                    </section>
                                  
            </div> 

            <script src="/index.4d6bcbeb.js" defer=""></script> 
    </body>
</html>